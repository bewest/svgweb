/*
Copyright (c) 2008 James Hight
Copyright (c) 2008 Richard R. Masters, for his changes.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

package com.zavoo.svg.nodes
{
    import com.zavoo.svg.data.SVGColors;
    import com.zavoo.svg.nodes.mask.SVGMask;
    import com.zavoo.svg.nodes.mask.SVGBlurMaskParent;
    import com.zavoo.svg.nodes.mask.SVGClipMaskParent;
    
    import flash.display.CapsStyle;
    import flash.display.DisplayObject;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.geom.Matrix;
    import flash.utils.*;
        
    /** Base node extended by all other SVG Nodes **/
    public class SVGNode extends Sprite
    {    
        public static const attributeList:Array = ['stroke', 'stroke-width', 'stroke-dasharray', 
                                         'stroke-opacity', 'stroke-linecap', 'stroke-linejoin',
                                         'fill', 'fill-opacity', 'opacity', 'stop-color', 'stop-opacity',
                                         'font-family', 'font-size', 'letter-spacing', 'filter'];
        
        
        public namespace xlink = 'http://www.w3.org/1999/xlink';
        public namespace svg = 'http://www.w3.org/2000/svg';
        
        /**
         * 
         **/ 
        public var svgRoot:SVGRoot = null;
            
        /**
         * SVG XML for this node
         **/    
        protected var _originalXML:XML; // used in case xlink:href is applied
        public var _xml:XML;
        protected var _revision:int = 0;
    
        /**
         * xlink:href base handling
         **/
        protected var _href:SVGNode; 
        protected var _hrefRevision:int = -1;

        /**
         * List of graphics commands to draw node.
         * Generated by generateGraphicsCommands()
         **/
        protected var _graphicsCommands:Array;

        /**
         * Used for caching node attribute style values. font, font-size, stroke, etc...
         * Set by setAttributes()
         * Used by getStyle()
         **/
        protected var _style:Object;

        /**
         * If true, redraw sprite graphics
         * Set to true on any change to xml
         **/
        protected var _invalidDisplay:Boolean = false;
        
        /**
         * Constructor
         *
         * @param xml XML object containing the SVG document. @default null    
         *
         * @return void.        
         */
        public function SVGNode(svgRoot:SVGRoot, xml:XML = null):void {    
            this.svgRoot = svgRoot;            
            this.xml = xml;            
            this.addEventListener(Event.ADDED, registerId);            
        }                    
        
        /** 
         * Called to generate AS3 graphics commands from the SVG instructions            
         **/
        protected function generateGraphicsCommands():void {
            this._graphicsCommands = new  Array();    
        }
        
        /**
         * Load attributes/styling from the XML. 
         * Attributes are applied in functions called later.
         **/
        protected function setAttributes():void {
            
            var xmlList:XMLList;
            this._style = new Object();
            //Get styling from XML attribute list
            for each (var attribute:String in SVGNode.attributeList) {
                xmlList = this._xml.attribute(attribute);
                if (xmlList.length() > 0) {
                    this._style[attribute] = xmlList[0].toString();
                }
            }
            
            //Get styling from XML attribute 'style'
            xmlList = this._xml.attribute('style');
            if (xmlList.length() > 0) {
                var styleString:String = xmlList[0].toString();
                var styles:Array = styleString.split(';');
                for each(var style:String in styles) {
                    var styleSet:Array = style.split(':');
                    if (styleSet.length == 2) {
                        var attrName:String = styleSet[0];
                        var attrValue:String = styleSet[1];
                        // Trim leading whitespace.
                        attrName = attrName.replace(/^\s+/, '');
                        attrValue = attrValue.replace(/^\s+/, '');
                        this._style[attrName] = attrValue;
                    }
                }
            }
            
            
            this.loadAttribute('x');    
            this.loadAttribute('y');
            this.loadAttribute('rotate', 'rotation');
            
            this.loadStyle('opacity', 'alpha');            
                                
        }
 

        public function overwriteStyles(baseStylesStr:String, newStylesStr:String):String {

            var mergedStyles:Object = new Object();
            var mergedStylesStr:String = "";
            var styleSet:Array;
            var attrName:String;
            var attrValue:String;
            var style:String;

            var baseStyles:Array = baseStylesStr.split(';');
            for each(style in baseStyles) {
                styleSet = style.split(':');
                if (styleSet.length == 2) {
                    attrName = styleSet[0];
                    attrValue = styleSet[1];
                    // Trim leading whitespace.
                    attrName = attrName.replace(/^\s+/, '');
                    attrValue = attrValue.replace(/^\s+/, '');
                    mergedStyles[attrName] = attrValue;
                }
            }

            var newStyles:Array = newStylesStr.split(';');
            for each(style in newStyles) {
                styleSet = style.split(':');
                if (styleSet.length == 2) {
                    attrName = styleSet[0];
                    attrValue = styleSet[1];
                    // Trim leading whitespace.
                    attrName = attrName.replace(/^\s+/, '');
                    attrValue = attrValue.replace(/^\s+/, '');
                    mergedStyles[attrName] = attrValue;
                }
            }

            for (attrName in mergedStyles) {
                mergedStylesStr = mergedStylesStr + attrName + ":" + mergedStyles[attrName] + ";";
            }
            return mergedStylesStr;
        }
            

        protected function parseTransform(trans:String):Matrix {
            if (trans != null) {
                var transArray:Array = trans.match(/\S+\(.*?\)/sg);
                for each(var tran:String in transArray) {
                    var tranArray:Array = tran.split('(',2);
                    if (tranArray.length == 2)
                    {                        
                        var command:String = String(tranArray[0]);
                        var args:String = String(tranArray[1]);
                        args = args.replace(')','');
                        args = args.replace(/ /g, '');
                        var argsArray:Array = args.split(/[,]/);
                        
                        var nodeMatrix:Matrix;
                        switch (command) {
                            case "matrix":
                                if (argsArray.length == 6) {
                                    nodeMatrix = new Matrix();
                                    nodeMatrix.a = argsArray[0];
                                    nodeMatrix.b = argsArray[1];
                                    nodeMatrix.c = argsArray[2];
                                    nodeMatrix.d = argsArray[3];
                                    nodeMatrix.tx = argsArray[4];
                                    nodeMatrix.ty = argsArray[5];
                                    return nodeMatrix;
                                }
                                break;

                            case "translate":
                                if (argsArray.length == 1) {
                                    nodeMatrix = new Matrix();
                                    nodeMatrix.tx = SVGColors.cleanNumber(argsArray[0])
                                    return nodeMatrix;
                                }
                                else if (argsArray.length == 2) {
                                    nodeMatrix = new Matrix();
                                    nodeMatrix.tx = SVGColors.cleanNumber(argsArray[0])
                                    nodeMatrix.ty = SVGColors.cleanNumber(argsArray[1])
                                    return nodeMatrix;
                                }
                                break;
                                
                            default:
                                this.svgRoot.debug('Unknown Transformation: ' + command);
                        }
                    }
                }                
            }
            return null;
        }
            
        /** 
         * Perform transformations defined by the transform attribute 
         **/
        protected function transformNode():void {
            
            var trans:String = this.getAttribute('transform');
            
            if (trans != null) {
                var transArray:Array = trans.match(/\S+\(.*?\)/sg);
                for each(var tran:String in transArray) {
                    var tranArray:Array = tran.split('(',2);
                    if (tranArray.length == 2)
                    {                        
                        var command:String = String(tranArray[0]);
                        var args:String = String(tranArray[1]);
                        args = args.replace(')','');
                        args = args.replace(/ /g, '');
                        var argsArray:Array = args.split(/[, ]/);
                        
                        switch (command) {
                            case "matrix":
                                if (argsArray.length == 6) {
                                    var nodeMatrix:Matrix = new Matrix();
                                    nodeMatrix.a = argsArray[0];
                                    nodeMatrix.b = argsArray[1];
                                    nodeMatrix.c = argsArray[2];
                                    nodeMatrix.d = argsArray[3];
                                    nodeMatrix.tx = argsArray[4];
                                    nodeMatrix.ty = argsArray[5];
                                    
                                    var matrix:Matrix = this.transform.matrix.clone();
                                    matrix.concat(nodeMatrix);
                                    this.transform.matrix = matrix;
                                    
                                }
                                break;
                                
                            case "translate":
                                if (argsArray.length == 1) {
                                    this.x = SVGColors.cleanNumber(argsArray[0]) + SVGColors.cleanNumber(this.getAttribute('x'));                                    
                                }
                                else if (argsArray.length == 2) {
                                    this.x = SVGColors.cleanNumber(argsArray[0]) + SVGColors.cleanNumber(this.getAttribute('x'));
                                    this.y = SVGColors.cleanNumber(argsArray[1]) + SVGColors.cleanNumber(this.getAttribute('y'));
                                }
                                break;
                                
                            case "scale":
                                if (argsArray.length == 1) {
                                    this.scaleX = argsArray[0];
                                    this.scaleY = argsArray[0];
                                }
                                else if (argsArray.length == 2) {
                                    this.scaleX = argsArray[0];
                                    this.scaleY = argsArray[1];
                                }
                                break;
                                
                            case "skewX":
                                // To Do
                                this.svgRoot.debug('Unimplemented Transformation: ' + command);
                                break;
                                
                            case "skewY":
                                // To Do
                                this.svgRoot.debug('Unimplemented Transformation: ' + command);
                                break;
                                
                            case "rotate":
                                this.rotation = argsArray[0];
                                break;
                                
                            default:
                                this.svgRoot.debug('Unknown Transformation: ' + command);
                        }
                    }
                }                
            }
/*
            if (this.parent is SVGMask && this.getSVGBlurMaskAncestor() != null) {
                var blurMask:SVGBlurMaskParent = this.getSVGBlurMaskAncestor();
                setTimeout(function():void { blurMask.updateBlurMaskTransform() }, 10);
            }
*/



        }
        
        /**
         * Load an XML attribute into the current node
         * 
         * @param name Name of the XML attribute to load
         * @param field Name of the node field to set. If null, the name attribute will be used as the field attribute.
         **/ 
        protected function loadAttribute(name:String, field:String = null):void {
            if (field == null) {
                field = name;
            }
            var tmp:String = this.getAttribute(name);
            if (tmp != null) {
                this[field] = SVGColors.cleanNumber(tmp);
            }
        } 
        
        /**
         * Load an SVG style into the current node
         * 
         * @param name Name of the SVG style to load
         * @param field Name of the node field to set. If null, the value of name will be used as the field attribute.
         **/ 
        protected function loadStyle(name:String, field:String = null):void {
            if (field == null) {
                field = name;
            }
            var tmp:String = this.getStyle(name);
            if (tmp != null) {
                this[field] = tmp;
            }
        }
        
        
        /** 
         * Clear current graphics and call runGraphicsCommands to render SVG element 
         **/
        protected function draw():void {
            //this.svgRoot.debug("drawing " + this._xml.@id);
            this.graphics.clear();            
            this.runGraphicsCommands();
            //this.svgRoot.debug("done drawing " + this._xml.@id);
            
        }
                
                
        /** 
         * Called at the start of drawing an SVG element.
         * Sets fill and stroke styles
         **/
        protected function nodeBeginFill():void {
            //Fill
            var fill_alpha:Number = 0;
            var fill_color:Number = 0;
            
            var fill:String = this.getStyle('fill');
            if ((fill != 'none') && (fill != '')) {
                var matches:Array = fill.match(/url\(#([^\)]+)\)/si);
                if (matches != null && matches.length > 0) {
                    var fillName:String = matches[1];
                    this.svgRoot.addReference(this.xml.@id, fillName);
                    var fillNode:SVGNode = this.svgRoot.getElement(fillName);
                    if (!fillNode) {
                         //this.svgRoot.debug("Gradient " + fillName + " not (yet?) available for " + this.xml.@id);
                    }
                    if (fillNode is SVGLinearGradient) {
                         SVGLinearGradient(fillNode).beginGradientFill(this, this.graphics);
                    }
                    if (fillNode is SVGRadialGradient) {
                         SVGRadialGradient(fillNode).beginGradientFill(this, this.graphics);
                    }
                }            
                else {            
                    fill_alpha = SVGColors.cleanNumber(this.getStyle('fill-opacity'));
                    fill_color = SVGColors.getColor(fill);
                    this.graphics.beginFill(fill_color, fill_alpha);
                }
            }
            
            //Stroke
            var line_color:Number;
            var line_alpha:Number;
            var line_width:Number;
            
            var stroke:String = this.getStyle('stroke');
            if ((stroke == 'none') || (stroke == '')) {
                line_alpha = 0;
                line_color = 0;
                line_width = 0;
            }
            else {
                line_color = SVGColors.cleanNumber(SVGColors.getColor(stroke));
                line_alpha = SVGColors.cleanNumber(this.getStyle('stroke-opacity'));
                line_width = SVGColors.cleanNumber(this.getStyle('stroke-width'));
            }
            
            var capsStyle:String = this.getStyle('stroke-linecap');
            if (capsStyle == 'round'){
                capsStyle = CapsStyle.ROUND;
            }
            if (capsStyle == 'square'){
                capsStyle = CapsStyle.SQUARE;
            }
            else {
                capsStyle = CapsStyle.NONE;
            }
            
            var jointStyle:String = this.getStyle('stroke-linejoin');
            if (jointStyle == 'round'){
                jointStyle = JointStyle.ROUND;
            }
            else if (jointStyle == 'bevel'){
                jointStyle = JointStyle.BEVEL;
            }
            else {
                jointStyle = JointStyle.MITER;
            }
            
            var miterLimit:String = this.getStyle('stroke-miterlimit');
            if (miterLimit == null) {
                miterLimit = '4';
            }

            this.graphics.lineStyle(line_width, line_color, line_alpha, false, LineScaleMode.NORMAL,
                                    capsStyle, jointStyle, SVGColors.cleanNumber(miterLimit));

            if ((stroke != 'none') && (stroke != '')) {
                var strokeMatches:Array = stroke.match(/url\(#([^\)]+)\)/si);
                if (strokeMatches != null && strokeMatches.length > 0) {
                    var strokeName:String = strokeMatches[1];
                    var strokeNode:SVGNode = this.svgRoot.getElement(strokeName);
                    if (!strokeNode) {
                         //this.svgRoot.debug("stroke gradient " + strokeName + " not (yet?) available for " + this.xml.@id);
                    }
                    if (strokeNode is SVGLinearGradient) {
                         SVGLinearGradient(strokeNode).lineGradientStyle(this, this.graphics, line_alpha);
                    }
                    if (strokeNode is SVGRadialGradient) {
                         SVGRadialGradient(strokeNode).lineGradientStyle(this, this.graphics, line_alpha);
                    }
                }            
            }
                    
        }
        
        /** 
         * Called at the end of drawing an SVG element
         **/
        protected function nodeEndFill():void {
            this.graphics.endFill();
        }
        
        /**
         * Execute graphics commands contained in var _graphicsCommands
         **/ 
        protected function runGraphicsCommands():void {
            
            var firstX:Number = 0;
            var firstY:Number = 0;
                    
            for each (var command:Array in this._graphicsCommands) {
                switch(command[0]) {
                    case "SF":
                        this.nodeBeginFill();
                        break;
                    case "EF":
                        this.nodeEndFill();
                        break;
                    case "M":
                        this.graphics.moveTo(command[1], command[2]);
                        //this.nodeBeginFill();
                        firstX = command[1];
                        firstY = command[2];
                        break;
                    case "L":
                        this.graphics.lineTo(command[1], command[2]);
                        break;
                    case "C":
                        this.graphics.curveTo(command[1], command[2],command[3], command[4]);
                        break;
                    case "Z":
                        this.graphics.lineTo(firstX, firstY);
                        //this.nodeEndFill();
                        break;
                    case "LINE":
                        this.nodeBeginFill();
                        this.graphics.moveTo(command[1], command[2]);
                        this.graphics.lineTo(command[3], command[4]);
                        this.nodeEndFill();                
                        break;
                    case "RECT":
                        this.nodeBeginFill();
                        if (command.length == 5) {
                            this.graphics.drawRect(command[1], command[2],command[3], command[4]);
                        }
                        else {
                            this.graphics.drawRoundRect(command[1], command[2],command[3], command[4], command[5], command[6]);
                        }
                        this.nodeEndFill();                
                        break;        
                    case "CIRCLE":
                        this.nodeBeginFill();
                        this.graphics.drawCircle(command[1], command[2], command[3]);
                        this.nodeEndFill();
                        break;
                    case "ELLIPSE":
                        this.nodeBeginFill();                        
                        this.graphics.drawEllipse(command[1], command[2],command[3], command[4]);
                        this.nodeEndFill();
                        break;
                }
            }
        }
        
        /**
         * If node has an "id" attribute, register it with the root node
         **/
        protected function registerId(event:Event):void {
            this.removeEventListener(Event.ADDED, registerId);
            
            var id:String = this._xml.@id;
            if (id != "") {
                //this.svgRoot.debug("registering " + id);
                this.svgRoot.registerElement(id, this);
            }
                        
        }
        
        /**
         * Parse the SVG XML.
         * This handles creation of child nodes.
         **/
        protected function parse():void {
            //this.svgRoot.debug("parse: " + this.xml.@id);
            // xxx we may miss referenced href changes because we only check hrefs
            // when this referencing object is redrawn. The fix
            // is to invalidate all referencing objects when any referenced
            // object is changed...
            this.refreshHref();
            
            for each (var childXML:XML in this._xml.children()) {    
                    
                if (childXML.nodeKind() == 'element') {
                    var newChildNode:SVGNode = this.parseNode(childXML);

                    if (!newChildNode) {
                        this.svgRoot.debug("did not add object!:" + childXML.localName());
                        continue;
                    }
                    newChildNode.refreshHref();
                    newChildNode.setAttributes();
                    var filterStr:String = newChildNode.getStyle('filter');

                    // Objects with a gaussian filter need to be 
                    // masked by their own shape to mask any gaussian blurs
                    // that might extend too far beyond the object boundaries.
                    // SVG clips this blur and so we have to create a mask here
                    // to mimic that behavior.

                    // A stub object is created as parent of the masking
                    // object and the masked object. The mask is applied to the parent
                    // stub object. This is done because if we apply a mask directly to
                    // an object with a gaussian filter, flash will blur the mask, even
                    // if the mask is not drawn with a blur.
                    // SVG does not blur its mask in this scenario so we apply the 
                    // mask to a stub parent object. 

                    // Note that if the object has a clip-path specified, then 
                    // the object will create a clip mask parent to hold the clip-path.
                    if (filterStr
                        && !(this.parent && this.parent.parent is SVGMask
                             && this.parent.parent.parent is SVGBlurMaskParent)
                        && !(this.parent && this.parent is SVGBlurMaskParent) ) {
                        newChildNode = new SVGBlurMaskParent(this.svgRoot, childXML, filterStr);
                    }
                    else {
                        if (childXML.@['clip-path'] != undefined) {
                            newChildNode = new SVGClipMaskParent(this.svgRoot, childXML);
                        }
                    }
                    this.addChild(newChildNode);
                }
            }
        }


        protected function parseNode(childXML:XML):SVGNode {
            var childNode:SVGNode = null;
            var nodeName:String = childXML.localName();
                    
            nodeName = nodeName.toLowerCase();

            switch(nodeName) {
                case "animate":
                    childNode = new SVGAnimateNode(this.svgRoot, childXML);
                    break;    
                case "animatemotion":
                    childNode = new SVGAnimateMotionNode(this.svgRoot, childXML);
                    break;    
                case "animatecolor":
                    childNode = new SVGAnimateColorNode(this.svgRoot, childXML);
                    break;    
                case "animatetransform":
                    childNode = new SVGAnimateTransformNode(this.svgRoot, childXML);
                    break;    
                case "circle":
                    childNode = new SVGCircleNode(this.svgRoot, childXML);
                    break;        
                case "clippath":
                    childNode = new SVGClipPathNode(this.svgRoot, childXML);
                    break;
                case "desc":
                    //Do Nothing
                    break;
                case "defs":
                    childNode = new SVGDefsNode(this.svgRoot, childXML);
                    break;
                case "ellipse":
                    childNode = new SVGEllipseNode(this.svgRoot, childXML);
                    break;
                case "filter":
                    childNode = new SVGFilterNode(this.svgRoot, childXML);
                    break;
                case "g":                        
                    childNode = new SVGGroupNode(this.svgRoot, childXML);
                    break;
                case "image":                        
                    childNode = new SVGImageNode(this.svgRoot, childXML);
                    break;
                case "line": 
                    childNode = new SVGLineNode(this.svgRoot, childXML);
                    break;    
                case "lineargradient": 
                    childNode = new SVGLinearGradient(this.svgRoot, childXML);
                    break;    
                case "mask":
                    childNode = new SVGMaskNode(this.svgRoot, childXML);
                    break;                        
                case "metadata":
                    //Do Nothing
                    break;
                case "namedview":
                    //Add Handling 
                    break;                            
                case "polygon":
                    childNode = new SVGPolygonNode(this.svgRoot, childXML);
                    break;
                case "polyline":
                    childNode = new SVGPolylineNode(this.svgRoot, childXML);
                    break;
                case "path":                        
                    childNode = new SVGPathNode(this.svgRoot, childXML);
                    break;
                case "radialgradient": 
                    childNode = new SVGRadialGradient(this.svgRoot, childXML);
                    break;    
                case "rect":
                    childNode = new SVGRectNode(this.svgRoot, childXML);
                    break;
                case "set":
                    childNode = new SVGSetNode(this.svgRoot, childXML);
                    break;
                case "stop":
                    childNode = new SVGGradientStop(this.svgRoot, childXML);            
                    break;
                case "symbol":
                    childNode = new SVGSymbolNode(this.svgRoot, childXML);
                    break;                        
                case "text":    
                    childNode = new SVGTextNode(this.svgRoot, childXML);
                    break; 
                case "title":    
                    childNode = new SVGTitleNode(this.svgRoot, childXML);
                    break; 
                case "tspan":                        
                    childNode = new SVGTspanNode(this.svgRoot, childXML);
                    break; 
                case "use":
                    childNode = new SVGUseNode(this.svgRoot, childXML);
                    break;
                case "null":
                    break;
                    
                default:
                    trace("Unknown Element: " + nodeName);
                    break;    
            }
            return childNode;
        }

        
        /**
         * Get a node style (ex: fill, stroke, etc..)
         * Also checks parent nodes for the value if it is not set in the current node.
         *
         * @param name Name of style to retreive
         * 
         * @return Value of style or null if it is not found
         **/
        public function getStyle(name:String):String {

            if (this.getSVGMaskAncestor() != null 
                 || (this is SVGClipMaskParent)
                 || (this is SVGBlurMaskParent)) {

                if (name == 'stroke-width') {
                    // must be a blur mask - add extra width

                    if ( (this.getSVGClipMaskAncestor() == null)
                         && !(this is SVGClipMaskParent)
                         && !(this is SVGBlurMaskParent)) {
                        return '30';
                    }

                    return '1';
                }
                if (  (name == 'opacity')
                    || (name == 'fill-opacity')
                    || (name == 'stroke-opacity') ) {
                    return '1';
                }

                if (name == 'fill') {
                    return 'black';
                }

                if (name == 'stroke') {
                    //return 'none';
                    return 'black';
                }

                if (name == 'filter') {
                    return null;
/*
                    if (this.getSVGClipMaskAncestor() != null) {
                        this.svgRoot.debug(this.xml.@id + ": Returning null filter for SVGMask child.");
                    }
*/
                }
            }

            if (this._style.hasOwnProperty(name)) {
                return this._style[name];
            }
            
            var attribute:String = this.getAttribute(name);
            if (attribute) {
                return attribute;
            }
            
            //Opacity should not be inherited
            else if (name == 'opacity') {
                return '1';
            }
            else if (this.parent is SVGNode) {
                return SVGNode(this.parent).getStyle(name);
            }
            return null;
        }
            
        /**
         * @param attribute Attribute to retrieve from SVG XML
         * 
         * @param defaultValue to return if attribute is not found
         * 
         * @return Returns the value of defaultValue
         **/
        protected function getAttribute(attribute:*, defaultValue:* = null):* {
            var xmlList:XMLList = this._xml.attribute(attribute);
            if (xmlList.length() > 0) {
                return xmlList[0].toString();
            }            
            return defaultValue;
            
        }
            
        
        /**
         * Remove all child nodes
         **/        
        protected function clearChildren():void {            
            while(this.numChildren) {
                this.removeChildAt(0);
            }
        }
        
                
        /**
         * Force a redraw of a node and its children
         **/
        public function invalidateDisplay():void {
            if (this._invalidDisplay == false) {
                this._invalidDisplay = true;
                this.addEventListener(Event.ENTER_FRAME, redrawNode);                
            }            
        }


        public function doRedrawNow():void {
            this.redrawNode(null);
        }

        /**
         * Triggers on ENTER_FRAME event
         * Redraws node graphics if _invalidDisplay == true
         **/
        protected function redrawNode(event:Event):void {
            if (this.parent == null) {
                return;
            }
            
            if (this._invalidDisplay) {                
                //this.svgRoot.debug("redrawNode: " + this.xml.@id + " type " + describeType(this).@name);
                if (this._xml != null) {    
                
                    this.graphics.clear();        
                    
                    this.parse();                        
                    this.x = 0;
                    this.y = 0;
                    this.setAttributes();                        

                    if (!this.isChildOfDef()) {
                        this.generateGraphicsCommands();    
                        this.transformNode();        
                        this.draw();    
                        this.setupFilters();                                
                    }
                }
                
                this._invalidDisplay = false;
                this.removeEventListener(Event.ENTER_FRAME, redrawNode);        

                if (this.xml.@id)  {
                    this.svgRoot.invalidateReferers(this.xml.@id) 
                }

/*
                if ((this.getSVGMaskAncestor() == null) && !(this is SVGClipMaskParent)) {
                    var blurMask:SVGBlurMaskParent = this.getSVGBlurMaskAncestor();
                    if (blurMask) {
                        this.svgRoot.debug("updating self blur mask transform " + describeType(this).@name);
                        setTimeout(function():void { blurMask.updateBlurMaskTransform() }, 10);
                    }
                }
*/

                //this.svgRoot.debug("done drawing " + this.xml.@id + " type " + describeType(this).@name);
            }
        }
        
        /**
         *
         **/
        override public function addChild(child:DisplayObject):DisplayObject {
            super.addChild(child);
            return child;
        }
        
        
        /**
         * Add any assigned filters to node
         **/
        protected function setupFilters():void {
            var filterName:String = this.getStyle('filter');
            if ((filterName != null)
                && (filterName != '')) {
                var matches:Array = filterName.match(/url\(#([^\)]+)\)/si);
                if (matches.length > 0) {
                    filterName = matches[1];
                    var filterNode:SVGFilterNode = this.svgRoot.getElement(filterName);
                    if (filterNode) {
                        this.filters = filterNode.getFilters(this);
                    }
                    else {
                        //this.svgRoot.debug("filter " + filterName + " not (yet?) available for " + this.xml.@id);
                        // xxx add reference
                    }
                }
            }
        }
                
        //Getters / Setters
        
        /**
         * @return Root SVG node
        public function get svgRoot():SVGRoot {
            if (this._svgRoot == null) {
                var node:SVGNode = this;
                while (!(node is SVGRoot)) {
                    node=SVGNode(node.parent);
                }
                this._svgRoot=SVGRoot(node);
            }
            return this._svgRoot;
        }
         **/ 

        /**
         * @return is child of definition? they are not drawn.
         **/ 
        public function isChildOfDef():Boolean {
            var node:SVGNode = this;
            while (node && !(node is SVGRoot)) {
                node=SVGNode(node.parent);
                if (node is SVGDefsNode)
                    return true;
            }
            return false;
        }

        public function getSVGMaskAncestor():SVGMask {
            var node:DisplayObject = this;
            if (node is SVGMask)
                return SVGMask(node);
            while (node && !(node is SVGRoot)) {
                node=node.parent;
                if (node && (node is SVGMask))
                    return SVGMask(node);
            }
            return null;
        }

        public function getSVGClipMaskAncestor():SVGClipMaskParent {
            var node:DisplayObject = this;
            while (node && !(node is SVGRoot)) {
                node=node.parent;
                if (node && (node is SVGClipMaskParent)) {
                    return SVGClipMaskParent(node);
                }
            }
            return null;
        }


        public function getSVGBlurMaskAncestor():SVGBlurMaskParent {
            var node:SVGNode = this;
            while (node && !(node is SVGRoot)) {
                node=SVGNode(node.parent);
                if (node && (node is SVGBlurMaskParent)) {
                    return SVGBlurMaskParent(node);
                }
            }
            return null;
        }



        public function get invalidDisplay():Boolean {
            return this._invalidDisplay;
        }
            
        /** 
         *
        **/        
        public function set xml(xml:XML):void {        
            this._originalXML = xml.copy();
            this._xml = xml;
            this._revision++;
            this.invalidateDisplay();
        }
        
        /**
         *
         **/
        public function get xml():XML {
            return this._xml;
        }

        /**
         *
         **/
        public function get id():String {
            var id:String = this._xml.@id;
            return id;
        }

        /** 
         *
        **/        
        public function get revision():int {        
            return this._revision;
        }
        


        /** 
         * @private
         * Temporary function to make debugging easier 
         **/
         public function get children():Array {
            var myChildren:Array = new Array();
            for (var i:int = 0; i < this.numChildren; i++) {
                myChildren.push(this.getChildAt(i));
            }
            return myChildren;
        } 
        
        /** 
         * @private
         * Temporary function to make debugging easier 
         **/
        public function get graphicsCommands():Array {
            return this._graphicsCommands;
        }
            
        
        /**
         * Set node style to new value
         * 
         * @param name Name of style
         * @param value New value for style
         **/
        public function setStyle(name:String, value:String):void {
            //Stick in the main attribute if it exists
            var attribute:String = this.getAttribute(name);
            if (attribute != null) {
                if (attribute != value) {
                    this._xml.@[name] = value;
                    this.invalidateDisplay();
                }
            }
            else {
                updateStyleString(name, value);
            }
        }
        
        /**
         * Update a value inside the attribute style
         * <node style="...StyleString...">
         * 
         * @param name Name of style
         * @param value New value for style
         **/ 
        private function updateStyleString(name:String, value:String):void {
            if (this._style[name] == value) {
                return;
            }
            
            this._style[name] = value;
            
            var newStyleString:String = '';
            
            for (var key:String in this._style) {
                if (newStyleString.length > 0) {
                    newStyleString += ';';
                }
                newStyleString += key + ':' + this._style[key];
            }
            
            this._xml.@style = newStyleString;        
            
            this.invalidateDisplay();
            
        }
        
        /**
         * Load _href content and then append/replace back original content
         **/
        public function refreshHref():void {

            /**
             * If _href revision has changed, copy xml over
             **/
            var href:String = this._xml.@xlink::href;
            if (!href || href=='') {
                href = this._xml.@href;
            }
//            this.svgRoot.debug("hrefresh: " + href + " mytype:" + describeType(this).@name + " myid: "+ this._xml.@id);

            if (href && href != '') {
                href = href.replace(/^#/,'');

                this._href = this.svgRoot.getElement(href);
                if (!this._href) {
                     //this.svgRoot.debug("href " + href + " not available for " + this.xml.@id);
                }
            }

            if (this._href
                && (this._href.revision != this._hrefRevision)) {
                //this.svgRoot.debug("Doing href refresh of " + this._xml.@xlink::href + " for " + this._xml.@id); 
                /**
                 * The call makes this refresh recursive
                 **/
                this._href.refreshHref();

                /**
                 * Copy the href
                 **/


                this._xml = this._originalXML.copy();

                /**
                 *
                 **/

                for (var index:int=0; index < this._href._xml.children().length(); index++) {
                    var childCopyXML:XML =this._href._xml.children()[index];
                    this._xml.appendChild(this.copyXMLUnique(childCopyXML).toXMLString());
                    
                }

                for each( var attr:XML in this._href.xml.attributes() ) {
                    this._xml.@[attr.name()] = attr.toString();
                }

                /**
                 * Replace the previous attributes since they have
                 * precedence over referenced xml.
                 **/
                for each( var myattr:XML in this._originalXML.attributes() ) {
                    if (myattr.name()  != "style") {
                        this._xml.@[myattr.name()] = myattr.toString();
                    }
                    else {
                        if (this._xml.@style) {
                            this._xml.@style = this.overwriteStyles(this.xml.@style, myattr.toString);
                        }
                        else {
                            this._xml.@style = myattr.toString;
                        }
                    }
                }


                this._revision++;
                this._hrefRevision = this._href._revision;
            }
            else {
                //this.svgRoot.debug("NOT Doing href refresh of " + this._xml.@xlink::href + " for " + this._xml.@id); 
                //this.svgRoot.debug("2NOT Doing href refresh of " + this._href + " type " + (typeof this._href)); 
            }
            return;
        }

        public function copyXMLUnique(originalXML:XML):XML {
            var myXML:XML = originalXML.copy();
            this.makeUniqueIDs(myXML);
            return myXML;
        }

        public function makeUniqueIDs(xmlNode:XML):void {

            if (xmlNode.@id && (xmlNode.@id != undefined)) {
               xmlNode.@id = xmlNode.@id + ".copy" + Math.random().toString();
            }
            else {
               xmlNode.@id = "copy" + Math.random().toString();
            }
            for each (var childXML:XML in xmlNode.children()) {
                this.makeUniqueIDs(childXML);
            }

        }

    }
}
