/*
 Copyright (c) 2009 by contributors:

 * James Hight (http://labs.zavoo.com/)
 * Richard R. Masters

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package com.sgweb.svg.core
{
    import com.sgweb.svg.utils.SVGColors;
    import com.sgweb.svg.utils.SVGUnits;
    import com.sgweb.svg.nodes.*;
    import com.sgweb.svg.nodes.mask.*;
    
    import flash.display.CapsStyle;
    import flash.display.DisplayObject;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.geom.Matrix;
    import flash.geom.Point;
    import flash.utils.getDefinitionByName;
    import flash.utils.getQualifiedClassName;

    /** Base node extended by all other SVG Nodes **/
    public class SVGNode extends Sprite
    {
        public static const ATTRIBUTES_NOT_INHERITED:Array = ['id', 'x', 'y', 'width', 'height', 'rotate', 'transform', 
                                        'gradientTransform', 'opacity', 'mask', 'clip-path', 'href', 'target', 'viewBox'];


        public namespace xlink = 'http://www.w3.org/1999/xlink';
        public namespace svg = 'http://www.w3.org/2000/svg';
        
        /**
         * 
         **/
        public var svgRoot:SVGRoot = null;

        /**
         * SVG XML for this node
         **/
        protected var _originalXML:XML; // used in case xlink:href is applied
        public var _xml:XML;
        protected var _revision:int = 0;

        /**
         * xlink:href base handling
         **/
        protected var _href:SVGNode; 
        protected var _hrefRevision:int = -1;

        /**
         * List of graphics commands to draw node.
         * Generated by generateGraphicsCommands()
         **/
        protected var _graphicsCommands:Array;
        public var scaleModeParam:String = "showAll_svg";

        protected var _styles:Object;

        /**
         * If true, redraw sprite graphics
         * Set to true on any change to xml
         **/
        protected var _invalidDisplay:Boolean = false;
        protected var _parsedChildren:Boolean = false;
        

        public var _initialRenderDone:Boolean = false;

        /**
         * Constructor
         *
         * @param xml XML object containing the SVG document. @default null
         *
         * @return void.
         */
        public function SVGNode(svgRoot:SVGRoot, xml:XML = null):void {
            this.svgRoot = svgRoot;
            this.xml = xml;
            this.addEventListener(Event.ADDED, registerId);
        }

        /** 
         * Called to generate AS3 graphics commands from the SVG instructions
         **/
        protected function generateGraphicsCommands():void {
            this._graphicsCommands = new  Array();    
        }

        protected function setAttributes():void {
            this.loadAttribute('x');
            this.loadAttribute('y');
            this.loadAttribute('rotate','rotation');
            this.loadAttribute('opacity','alpha');
        }

        public static function overwriteStyles(baseStylesStr:String, newStylesStr:String):String {

            var mergedStyles:Object = new Object();
            var mergedStylesStr:String = "";
            var styleSet:Array;
            var attrName:String;
            var attrValue:String;
            var style:String;

            // Create an object with the base styles
            var baseStyles:Array = baseStylesStr.split(';');
            for each(style in baseStyles) {
                styleSet = style.split(':');
                if (styleSet.length == 2) {
                    attrName = styleSet[0];
                    attrValue = styleSet[1];
                    // Trim leading whitespace.
                    attrName = attrName.replace(/^\s+/, '');
                    attrValue = attrValue.replace(/^\s+/, '');
                    mergedStyles[attrName] = attrValue;
                }
            }

            // Set the new styles over the base styles
            var newStyles:Array = newStylesStr.split(';');
            for each(style in newStyles) {
                styleSet = style.split(':');
                if (styleSet.length == 2) {
                    attrName = styleSet[0];
                    attrValue = styleSet[1];
                    // Trim leading whitespace.
                    attrName = attrName.replace(/^\s+/, '');
                    attrValue = attrValue.replace(/^\s+/, '');
                    // overwriting fills have special rules.
                    // url gradients take precedence over new rgb
                    if (attrName == 'fill' && mergedStyles[attrName] != undefined) {
                        if (   (mergedStyles[attrName].indexOf('url') == -1)
                            || (attrValue.indexOf('url') != -1) ) {
                            mergedStyles[attrName] = attrValue;
                        }
                    }
                    else {
                        mergedStyles[attrName] = attrValue;
                    }
                }
            }

            for (attrName in mergedStyles) {
                mergedStylesStr = mergedStylesStr + attrName + ":" + mergedStyles[attrName] + ";";
            }
            return mergedStylesStr;
        }
            

        public function parseTransform(trans:String, baseMatrix:Matrix = null):Matrix {
            if (!baseMatrix) {
                baseMatrix = new Matrix();
            }
            
            if (trans != null) {
                var transArray:Array = trans.match(/\S+\(.*?\)/sg);
                transArray.reverse();
                for each(var tran:String in transArray) {
                    var tranArray:Array = tran.split('(',2);
                    if (tranArray.length == 2)
                    {
                        var command:String = String(tranArray[0]);
                        var args:String = String(tranArray[1]);
                        args = args.replace(')','');
                        args = args.replace(/ /g, '');
                        var argsArray:Array = args.split(/[, ]/);

                        var nodeMatrix:Matrix = new Matrix();
                        switch (command) {
                            case "matrix":
                                if (argsArray.length == 6) {
                                    nodeMatrix.a = argsArray[0];
                                    nodeMatrix.b = argsArray[1];
                                    nodeMatrix.c = argsArray[2];
                                    nodeMatrix.d = argsArray[3];
                                    nodeMatrix.tx = argsArray[4];
                                    nodeMatrix.ty = argsArray[5];
                                }
                                break;

                            case "translate":
                                if (argsArray.length == 1) {
                                    nodeMatrix.tx = argsArray[0]; 
                                }
                                else if (argsArray.length == 2) {
                                    nodeMatrix.tx = argsArray[0]; 
                                    nodeMatrix.ty = argsArray[1]; 
                                }
                                break;

                            case "scale":
                                if (argsArray.length == 1) {
                                    nodeMatrix.a = argsArray[0];
                                    nodeMatrix.d = argsArray[0];
                                }
                                else if (argsArray.length == 2) {
                                    nodeMatrix.a = argsArray[0];
                                    nodeMatrix.d = argsArray[1];
                                }
                                break;
                                
                            case "skewX":
                                nodeMatrix.c = Math.tan(argsArray[0] * Math.PI / 180.0);
                                break;
                                
                            case "skewY":
                                nodeMatrix.b = Math.tan(argsArray[0] * Math.PI / 180.0);
                                break;
                                
                            case "rotate":
                                nodeMatrix.rotate(Number(argsArray[0])* Math.PI / 180.0); 
                                break;
                                
                            default:
                                //this.dbg('Unknown Transformation: ' + command);
                        }
                        baseMatrix.concat(nodeMatrix);
                    }
                }
            }
            
            return baseMatrix;
        }


        public function getWidth():Number {
            if (this.xml.@width) {
                var widthStr:String = this.xml.@width;
                if (widthStr.match(/%/)) {
                    widthStr=widthStr.replace(/%/g, "");
                    var num:Number = SVGColors.cleanNumber(widthStr);
                    if (this.parent) {
                        return SVGNode(this.parent).getWidth() * num / 100;
                    }
                    else {
                        return 0;
                    }
                }
                else {
                    return SVGColors.cleanNumber(widthStr);
                }
            }
            else
                return SVGNode(this.parent).getWidth();
        }


        public function getHeight():Number {
            if (this.xml.@height) {
                var heightStr:String = this.xml.@height;
                if (heightStr.match(/%/)) {
                    heightStr=heightStr.replace(/%/g, "");
                    var num:Number = SVGColors.cleanNumber(heightStr);
                    if (this.parent) {
                        return SVGNode(this.parent).getHeight() * num / 100;
                    }
                    else {
                        return 0;
                    }
                }
                else {
                    return SVGColors.cleanNumber(heightStr);
                }
            }
            else
                return SVGNode(this.parent).getWidth();
        }




        /**
         * Perform transformations defined by the transform attribute 
         **/
        public function transformNode():void {
            var canvasWidth:Number;
            var canvasHeight:Number;
            var newMatrix:Matrix;

            var undoViewBoxMatrix:Matrix = new Matrix();

            this.transform.matrix = new Matrix();
            this.loadAttribute('x');    
            this.loadAttribute('y');

            // XXX hack because tspan x,y apparently replaces
            // the parent text x,y instead of offsetting the
            // parent like every other node. the 'correct'
            // calculation is commented out because it does
            // not work currently
            if (this is SVGTspanNode) {
                this.x = 0;
                this.y = 0;
                //this.x = this.x - this.parent.x;
                //this.y = this.y - this.parent.y;
            }
            
            this.loadAttribute('rotate', 'rotation');

            newMatrix = this.transform.matrix.clone();

            // <svg> and <image> nodes get an implicit mask of their height and width
            if (this is SVGRoot || this is SVGSVGNode || this is SVGImageNode) {
                if (   (this.xml.@width != undefined) 
                    && (this.xml.@height != undefined) ) {
                    canvasWidth = SVGColors.cleanNumber2(this.xml.@width, this.getWidth());
                    canvasHeight = SVGColors.cleanNumber2(this.xml.@height, this.getHeight());
                    if (this.mask == null) {
                        var myMask:Shape = new Shape();
                        this.addChild(myMask);
                        this.mask = myMask;
                    }
                    if (this.mask is Shape) {
                        Shape(this.mask).graphics.clear();
                        Shape(this.mask).graphics.beginFill(0x000000);
                        Shape(this.mask).graphics.drawRect(0, 0, canvasWidth, canvasHeight);
                        Shape(this.mask).graphics.endFill();
                    }
                }
            }

            // Apply viewbox transform
            var viewBox:String = this.getAttribute('viewBox');
            if (viewBox != null ||
                   (    (this._xml.@preserveAspectRatio != undefined) 
                     && (this._xml.@width != undefined)
                     && (this._xml.@height != undefined) ) ) {

                /**
                 * Canvas, the viewport
                 **/
                canvasWidth = 2048.0;
                canvasHeight =1024.0;

                if (this.scaleModeParam == "showAll_svg") {
                    canvasWidth = this.stage.stageWidth;
                    canvasHeight = this.stage.stageHeight;
                }

                if (this.xml.@width != undefined) {
                    canvasWidth = SVGColors.cleanNumber2(this.xml.@width, canvasWidth);
                }
                if (this.xml.@height != undefined) {
                    canvasHeight = SVGColors.cleanNumber2(this.xml.@height, canvasHeight);
                }

                /**
                 * Viewbox
                 **/
                var viewX:Number;
                var viewY:Number;
                var viewWidth:Number;
                var viewHeight:Number;
                if (viewBox != null) {
                    var points:Array = viewBox.split(/\s+/);
                    viewX = SVGColors.cleanNumber(points[0]);
                    viewY = SVGColors.cleanNumber(points[1]);
                    viewWidth = SVGColors.cleanNumber(points[2]);
                    viewHeight = SVGColors.cleanNumber(points[3]);
                }
                else {
                    viewX = 0;
                    viewY = 0;
                    viewWidth = canvasWidth;
                    viewHeight = canvasHeight;
                    if (this is SVGImageNode) {
                        if (SVGImageNode(this).imageWidth > 0) {
                            viewWidth = SVGImageNode(this).imageWidth;
                        }
                        if (SVGImageNode(this).imageHeight > 0) {
                            viewHeight = SVGImageNode(this).imageHeight;
                        }
                    }
                }


                var oldAspectRes:Number = viewWidth / viewHeight;
                var newAspectRes:Number = canvasWidth /  canvasHeight;
                var cropWidth:Number;
                var cropHeight:Number;

                var preserveAspectRatio:String = 'xMidYMid meet';
                if (this.xml.@preserveAspectRatio != undefined) {
                    preserveAspectRatio = this.xml.@preserveAspectRatio.toString();
                }
                var alignMode:String = preserveAspectRatio.substr(0,8);
                var meetOrSlice:String = 'meet';
                if (preserveAspectRatio.indexOf('slice') != -1) {
                    meetOrSlice = 'slice';
                }

                /**
                 * Handle Scaling
                 **/
                if (alignMode == 'none') {
                    // stretch to fit viewport width and height

                    cropWidth = canvasWidth;
                    cropHeight = canvasHeight;
                }
                else {
                    if (meetOrSlice == 'meet') {
                        // shrink to fit inside viewport

                        if (newAspectRes > oldAspectRes) {
                            cropWidth = canvasHeight * oldAspectRes;
                            cropHeight = canvasHeight;
                        }
                        else {
                            cropWidth = canvasWidth;
                            cropHeight = canvasWidth / oldAspectRes;
                        }
    
                    }
                    else {
                        // meetOrSlice == 'slice'
                        // Expand to cover viewport.

                        if (newAspectRes > oldAspectRes) {
                            cropWidth = canvasWidth;
                            cropHeight = canvasWidth / oldAspectRes;
                        }
                        else {
                            cropWidth = canvasHeight * oldAspectRes;
                            cropHeight = canvasHeight;
                        }
    
                    }
                }
                var scaleX:Number = cropWidth / viewWidth;
                var scaleY:Number = cropHeight / viewHeight;
                newMatrix.translate(-viewX, -viewY);
                undoViewBoxMatrix.translate(viewX, viewY);
                newMatrix.scale(scaleX, scaleY);
                undoViewBoxMatrix.scale(1/scaleX, 1/scaleY);


                /**
                 * Handle Alignment
                 **/
                var borderX:Number;
                var borderY:Number;
                var translateX:Number;
                var translateY:Number;
                if (alignMode != 'none') {
                    translateX=0;
                    translateY=0;
                    var xAlignMode:String = alignMode.substr(0,4);
                    switch (xAlignMode) {
                        case 'xMin':
                            break;
                        case 'xMax':
                            translateX = canvasWidth - cropWidth;
                            break;
                        case 'xMid':
                        default:
                            borderX = canvasWidth - cropWidth;
                            translateX = borderX / 2.0;
                            break;
                    }
                    var yAlignMode:String = alignMode.substr(4,4);
                    switch (yAlignMode) {
                        case 'YMin':
                            break;
                        case 'YMax':
                            translateY = canvasHeight - cropHeight;
                            break;
                        case 'YMid':
                        default:
                            borderY = canvasHeight - cropHeight;
                            translateY = borderY / 2.0;
                            break;
                    }
                    newMatrix.translate(translateX, translateY);
                    undoViewBoxMatrix.translate(-translateX/scaleX, -translateY/scaleY);
                    undoViewBoxMatrix.translate(translateX, translateY);
                }
            }

            this.transform.matrix = newMatrix;
            newMatrix = this.transform.matrix.clone();


            // Apply transform attribute 
            var trans:String = this.getAttribute('transform');
            var nodeMatrix:Matrix;
            if (trans != null) {
                var transArray:Array = trans.match(/\S+\(.*?\)/sg);
                transArray.reverse();
                for each(var tran:String in transArray) {
                    var tranArray:Array = tran.split('(',2);
                    if (tranArray.length == 2)
                    {
                        var command:String = String(tranArray[0]);
                        var args:String = String(tranArray[1]);
                        args = args.replace(')','');
                        args = args.replace(/ /g, '');
                        var argsArray:Array = args.split(/[, ]/);

                        nodeMatrix = new Matrix();
                        switch (command) {
                            case "matrix":
                                if (argsArray.length == 6) {
                                    nodeMatrix.a = argsArray[0];
                                    nodeMatrix.b = argsArray[1];
                                    nodeMatrix.c = argsArray[2];
                                    nodeMatrix.d = argsArray[3];
                                    nodeMatrix.tx = argsArray[4];
                                    nodeMatrix.ty = argsArray[5];
                                }
                                break;

                            case "translate":
                                if (argsArray.length == 1) {
                                    nodeMatrix.tx = argsArray[0]; 
                                }
                                else if (argsArray.length == 2) {
                                    nodeMatrix.tx = argsArray[0]; 
                                    nodeMatrix.ty = argsArray[1]; 
                                }
                                break;

                            case "scale":
                                if (argsArray.length == 1) {
                                    nodeMatrix.a = argsArray[0];
                                    nodeMatrix.d = argsArray[0];
                                }
                                else if (argsArray.length == 2) {
                                    nodeMatrix.a = argsArray[0];
                                    nodeMatrix.d = argsArray[1];
                                }
                                break;
                                
                            case "skewX":
                                nodeMatrix.c = Math.tan(argsArray[0] * Math.PI / 180.0);
                                break;
                                
                            case "skewY":
                                nodeMatrix.b = Math.tan(argsArray[0] * Math.PI / 180.0);
                                break;
                                
                            case "rotate":
                                nodeMatrix.rotate(Number(argsArray[0])* Math.PI / 180.0); 
                                break;
                                
                            default:
                                this.dbg('Unknown Transformation: ' + command);
                        }
                        newMatrix.concat(nodeMatrix);
                        this.transform.matrix = newMatrix;
                        newMatrix = this.transform.matrix.clone();
                    }
                }
            }
            // Reverse all tranforms against the mask because the viewbox coordinates are
            // in the parent coordinate space. Since the mask is a child of this node,
            // the resulting coordinate mismatch is unfortunate.
            if (this.mask is Shape) {
                var maskMatrix:Matrix = new Matrix();
                if (this is SVGImageNode) {
                    maskMatrix.concat(undoViewBoxMatrix);
                }
                else {
                    newMatrix.invert();
                    maskMatrix.concat(newMatrix);
                }
                this.mask.transform.matrix = maskMatrix;
            }

            // Our x,y should not be affected by viewbox transform.
            // xxx perhaps we should apply the transform to the child
            // bitmap image object so the SVGImageNode coordinates are not affected!
            if (this is SVGImageNode) {
                var myPos:Point = new Point(this.x, this.y);
                myPos = undoViewBoxMatrix.transformPoint(myPos);
                this.x = myPos.x;
                this.y = myPos.y;
            }


/* blur mask is disabled because it appears it can only be computed
   reliably for simple svg elements
            if (this.parent is SVGMask && this.getSVGBlurMaskAncestor() != null) {
                var blurMask:SVGBlurMaskParent = this.getSVGBlurMaskAncestor();
                setTimeout(function():void { blurMask.updateBlurMaskTransform() }, 10);
            }
*/



        }

        /**
         * Load an XML attribute into the current node
         * 
         * @param name Name of the XML attribute to load
         * @param field Name of the node field to set. If null, the name attribute will be used as the field attribute.
         **/ 
        protected function loadAttribute(name:String, field:String = null):void {
            if (field == null) {
                field = name;
            }
            var tmp:String = this.getAttribute(name);
            if (tmp != null) {
                if (name == 'x') {
                    this[field] = SVGColors.cleanNumber2(tmp, this.getWidth());
                    return;
                }
                if (name == 'y') {
                    this[field] = SVGColors.cleanNumber2(tmp, this.getHeight());
                    return;
                }
                if (name == 'width') {
                    this[field] = SVGColors.cleanNumber2(tmp, this.getWidth());
                    return;
                }
                if (name == 'height') {
                    this[field] = SVGColors.cleanNumber2(tmp, this.getHeight());
                    return;
                }
                this[field] = SVGColors.cleanNumber(tmp);
            }
        } 

        /** 
         * Clear current graphics and call runGraphicsCommands to render SVG element 
         **/
        protected function draw():void {
            this.graphics.clear();            
            this.runGraphicsCommands();
        }


        /** 
         * Called at the start of drawing an SVG element.
         * Sets fill and stroke styles
         **/
        protected function nodeBeginFill():void {
            //Fill
            var color_and_alpha:Array = [0, 0];
            var color_core:Number = 0;
            var color_alpha:Number = 0;
            var fill_alpha:Number = 0;

            var fill:String = this.getAttribute('fill');
            if ( (fill != 'none') && (fill != '') && (this.getAttribute('visibility') != 'hidden') ) {
                var matches:Array = fill.match(/url\(#([^\)]+)\)/si);
                if (matches != null && matches.length > 0) {
                    var fillName:String = matches[1];
                    this.svgRoot.addReference(this.xml.@id, fillName);
                    var fillNode:SVGNode = this.svgRoot.getElement(fillName);
                    if (!fillNode) {
                         // this happens normally
                         //this.dbg("Gradient " + fillName + " not (yet?) available for " + this.xml.@id);
                    }
                    if (fillNode is SVGLinearGradient) {
                         SVGLinearGradient(fillNode).beginGradientFill(this, this.graphics);
                    }
                    if (fillNode is SVGRadialGradient) {
                         SVGRadialGradient(fillNode).beginGradientFill(this, this.graphics);
                    }
                }
                else {
                    color_and_alpha = SVGColors.getColorAndAlpha(fill);
                    color_core = color_and_alpha[0];
                    color_alpha = color_and_alpha[1];
                    fill_alpha = SVGColors.cleanNumber( this.getAttribute('fill-opacity') ) * color_alpha;
                    this.graphics.beginFill(color_core, fill_alpha);
                }
            }

            //Stroke
            var line_color:Number;
            var line_alpha:Number;
            var line_width:Number;

            var stroke:String = this.getAttribute('stroke');
            if ( (stroke == 'none') || (stroke == '') || (this.getAttribute('visibility') == 'hidden') ) {
                line_alpha = 0;
                line_color = 0;
                line_width = 0;
            }
            else {
                line_color = SVGColors.cleanNumber(SVGColors.getColor(stroke));
                line_alpha = SVGColors.cleanNumber(this.getAttribute('stroke-opacity'));
                line_width = SVGColors.cleanNumber(this.getAttribute('stroke-width'));
            }

            var capsStyle:String = this.getAttribute('stroke-linecap');
            if (capsStyle == 'round'){
                capsStyle = CapsStyle.ROUND;
            }
            if (capsStyle == 'square'){
                capsStyle = CapsStyle.SQUARE;
            }
            else {
                capsStyle = CapsStyle.NONE;
            }
            
            var jointStyle:String = this.getAttribute('stroke-linejoin');
            if (jointStyle == 'round'){
                jointStyle = JointStyle.ROUND;
            }
            else if (jointStyle == 'bevel'){
                jointStyle = JointStyle.BEVEL;
            }
            else {
                jointStyle = JointStyle.MITER;
            }
            
            var miterLimit:String = this.getAttribute('stroke-miterlimit');
            if (miterLimit == null) {
                miterLimit = '4';
            }

            this.graphics.lineStyle(line_width, line_color, line_alpha, false, LineScaleMode.NORMAL,
                                    capsStyle, jointStyle, SVGColors.cleanNumber(miterLimit));

            if ( (stroke != 'none') && (stroke != '')  && (this.getAttribute('visibility') != 'hidden') ) {
                var strokeMatches:Array = stroke.match(/url\(#([^\)]+)\)/si);
                if (strokeMatches != null && strokeMatches.length > 0) {
                    var strokeName:String = strokeMatches[1];
                    this.svgRoot.addReference(this.xml.@id, strokeName);
                    var strokeNode:SVGNode = this.svgRoot.getElement(strokeName);
                    if (!strokeNode) {
                         // this happens normally
                         //this.dbg("stroke gradient " + strokeName + " not (yet?) available for " + this.xml.@id);
                    }
                    if (strokeNode is SVGLinearGradient) {
                         SVGLinearGradient(strokeNode).lineGradientStyle(this, this.graphics, line_alpha);
                    }
                    if (strokeNode is SVGRadialGradient) {
                         SVGRadialGradient(strokeNode).lineGradientStyle(this, this.graphics, line_alpha);
                    }
                }
            }

        }
        
        /** 
         * Called at the end of drawing an SVG element
         **/
        protected function nodeEndFill():void {
            this.graphics.endFill();
        }

        /**
         * Execute graphics commands contained in var _graphicsCommands
         **/ 
        protected function runGraphicsCommands():void {

            var firstX:Number = 0;
            var firstY:Number = 0;

            for each (var command:Array in this._graphicsCommands) {
                switch(command[0]) {
                    case "SF":
                        this.nodeBeginFill();
                        break;
                    case "EF":
                        this.nodeEndFill();
                        break;
                    case "M":
                        this.graphics.moveTo(command[1], command[2]);
                        //this.nodeBeginFill();
                        firstX = command[1];
                        firstY = command[2];
                        break;
                    case "L":
                        this.graphics.lineTo(command[1], command[2]);
                        break;
                    case "C":
                        this.graphics.curveTo(command[1], command[2],command[3], command[4]);
                        break;
                    case "Z":
                        this.graphics.lineTo(firstX, firstY);
                        //this.nodeEndFill();
                        break;
                    case "LINE":
                        this.nodeBeginFill();
                        this.graphics.moveTo(command[1], command[2]);
                        this.graphics.lineTo(command[3], command[4]);
                        this.nodeEndFill();                
                        break;
                    case "RECT":
                        this.nodeBeginFill();
                        if (command.length == 5) {
                            this.graphics.drawRect(command[1], command[2],command[3], command[4]);
                        }
                        else {
                            this.graphics.drawRoundRect(command[1], command[2],command[3], command[4], command[5], command[6]);
                        }
                        this.nodeEndFill();                
                        break;        
                    case "CIRCLE":
                        this.nodeBeginFill();
                        this.graphics.drawCircle(command[1], command[2], command[3]);
                        this.nodeEndFill();
                        break;
                    case "ELLIPSE":
                        this.nodeBeginFill();                        
                        this.graphics.drawEllipse(command[1], command[2],command[3], command[4]);
                        this.nodeEndFill();
                        break;
                }
            }
        }

        /**
         * If node has an "id" attribute, register it with the root node
         **/
        protected function registerId(event:Event):void {
            this.removeEventListener(Event.ADDED, registerId);
            
            var id:String = this._xml.@id;
            if (id != "") {
                //this.dbg("registering " + id);
                this.svgRoot.registerElement(id, this);
            }

        }

        /**
         * Parse the SVG XML.
         * This handles creation of child nodes.
         **/
        protected function parse():void {
            //this.dbg("parse: " + this.xml.@id + " type " + describeType(this).@name);
            this.refreshHref();
            
            for each (var childXML:XML in this._xml.children()) {    

                if (childXML.nodeKind() == 'element') {

                    // This handle strange gradient bugs with negative transforms
                    // by separating the transform from every object
                    if (childXML.@['transform'] != undefined) {
                        var newChildXML:XML = childXML.copy();
                        var stubGroupXML:XML = <g></g>;
                        stubGroupXML.@['transform'] = newChildXML.@['transform'];
                        delete newChildXML.@['transform'];
                        stubGroupXML.appendChild(newChildXML.toXMLString());
                        newChildNode = new SVGGroupNode(this.svgRoot, stubGroupXML);
                        this.addChild(newChildNode);
                        continue;
                    }
                    var newChildNode:SVGNode = this.parseNode(childXML);

                    if (!newChildNode) {
                        if (childXML.localName() == 'script') {
                            var scriptString:String = childXML.toXMLString();
                            scriptString = scriptString.split('\\n').join(';_SVGNL_;');
                            scriptString = scriptString.replace(/<script.*/, '');
                            scriptString = scriptString.replace(/<svg:script.*/, '');
                            scriptString = scriptString.replace(/]].*$/, '');
                            this.svgRoot.handleScript(scriptString);
                        }
                        else {
                            this.dbg("did not add object!:" + childXML.localName());
                        }
                        continue;
                    }
                    newChildNode.refreshHref();

                    var filterStr:String = newChildNode.getAttribute('filter');

                    // Objects with a gaussian filter need to be 
                    // masked by their own shape to mask any gaussian blurs
                    // that might extend too far beyond the object boundaries.
                    // SVG clips this blur and so we have to create a mask here
                    // to mimic that behavior.

                    // A stub object is created as parent of the masking
                    // object and the masked object. The mask is applied to the parent
                    // stub object. This is done because if we apply a mask directly to
                    // an object with a gaussian filter, flash will blur the mask, even
                    // if the mask is not drawn with a blur.
                    // SVG does not blur its mask in this scenario so we apply the 
                    // mask to a stub parent object. 

                    // Note that if the object has a clip-path specified, then 
                    // the object will create a clip mask parent to hold the clip-path.
                    if (filterStr
                        && !(this.parent && this.parent.parent is SVGMask
                             && this.parent.parent.parent is SVGBlurMaskParent)
                        && !(this.parent && this.parent is SVGBlurMaskParent) ) {
                        newChildNode = new SVGBlurMaskParent(this.svgRoot, childXML, filterStr);
                    }
                    else {
                        if (    (childXML.@['clip-path'] != undefined)
                             || (childXML.@['mask'] != undefined) ) {
                            newChildNode = new SVGClipMaskParent(this.svgRoot, childXML);
                        }
                    }
                    this.addChild(newChildNode);
                }
            }
        }


        public function parseNode(childXML:XML):SVGNode {
            var childNode:SVGNode = null;
            var nodeName:String = childXML.localName();
                    
            nodeName = nodeName.toLowerCase();

            switch(nodeName) {
                case "a":
                    childNode = new SVGANode(this.svgRoot, childXML);
                    break;
                case "animate":
                    childNode = new SVGAnimateNode(this.svgRoot, childXML);
                    break;    
                case "animatemotion":
                    childNode = new SVGAnimateMotionNode(this.svgRoot, childXML);
                    break;    
                case "animatecolor":
                    childNode = new SVGAnimateColorNode(this.svgRoot, childXML);
                    break;    
                case "animatetransform":
                    childNode = new SVGAnimateTransformNode(this.svgRoot, childXML);
                    break;    
                case "circle":
                    childNode = new SVGCircleNode(this.svgRoot, childXML);
                    break;        
                case "clippath":
                    childNode = new SVGClipPathNode(this.svgRoot, childXML);
                    break;
                case "desc":
                    //Do Nothing
                    break;
                case "defs":
                    childNode = new SVGDefsNode(this.svgRoot, childXML);
                    break;
                case "ellipse":
                    childNode = new SVGEllipseNode(this.svgRoot, childXML);
                    break;
                case "filter":
                    childNode = new SVGFilterNode(this.svgRoot, childXML);
                    break;
                case "g":                        
                    childNode = new SVGGroupNode(this.svgRoot, childXML);
                    break;
                case "image":                        
                    childNode = new SVGImageNode(this.svgRoot, childXML);
                    break;
                case "line": 
                    childNode = new SVGLineNode(this.svgRoot, childXML);
                    break;    
                case "lineargradient": 
                    childNode = new SVGLinearGradient(this.svgRoot, childXML);
                    break;    
                case "mask":
                    childNode = new SVGMaskNode(this.svgRoot, childXML);
                    break;                        
                case "metadata":
                    //Do Nothing
                    break;
                case "namedview":
                    //Add Handling 
                    break;                            
                case "polygon":
                    childNode = new SVGPolygonNode(this.svgRoot, childXML);
                    break;
                case "polyline":
                    childNode = new SVGPolylineNode(this.svgRoot, childXML);
                    break;
                case "path":                        
                    childNode = new SVGPathNode(this.svgRoot, childXML);
                    break;
                case "radialgradient": 
                    childNode = new SVGRadialGradient(this.svgRoot, childXML);
                    break;    
                case "rect":
                    childNode = new SVGRectNode(this.svgRoot, childXML);
                    break;
                case "set":
                    childNode = new SVGSetNode(this.svgRoot, childXML);
                    break;
                case "stop":
                    childNode = new SVGGradientStop(this.svgRoot, childXML);            
                    break;
                case "svg":
                    childNode = new SVGSVGNode(this.svgRoot, childXML);
                    break;                        
                case "symbol":
                    childNode = new SVGSymbolNode(this.svgRoot, childXML);
                    break;                        
                case "text":    
                    childNode = new SVGTextNode(this.svgRoot, childXML);
                    break; 
                case "title":    
                    childNode = new SVGTitleNode(this.svgRoot, childXML);
                    break; 
                case "tspan":                        
                    childNode = new SVGTspanNode(this.svgRoot, childXML);
                    break; 
                case "use":
                    childNode = new SVGUseNode(this.svgRoot, childXML);
                    break;
                case "null":
                    break;
                    
                default:
                    trace("Unknown Element: " + nodeName);
                    break;    
            }
            return childNode;
        }

        private function parseStyle():void {
            //Get styling from XML attribute 'style'
            _styles = new Object();
            
            var xmlList:XMLList = this._xml.attribute('style');
            if (xmlList.length() > 0) {
                var styleString:String = xmlList[0].toString();
                var styles:Array = styleString.split(';');
                for each(var style:String in styles) {
                    var styleSet:Array = style.split(':');
                    if (styleSet.length == 2) {
                        this._styles[SVGColors.trim(styleSet[0])] = SVGColors.trim(styleSet[1]);
                    }
                }
            }
        }

        /**
         * @param attribute Attribute to retrieve from SVG XML
         * 
         * @param defaultValue Value to return if attribute is not found
         * 
         * @param inherit If attribute is not set in this node try to retrieve it from the parent node
         * 
         * @return Returns the value of defaultValue
         **/
        public function getAttribute(name:String, defaultValue:* = null, inherit:Boolean = true):* {            
            var value:String = this._getAttribute(name);
            
            if (value == "inherit") {
                value = null;
            }
            
            if (value) {
                return value;
            }
            
            if (ATTRIBUTES_NOT_INHERITED.indexOf(name) != -1) {            
                return defaultValue;        
            }
            
            if (inherit && (this.parent is SVGNode)) {
                return SVGNode(this.parent).getAttribute(name, defaultValue);
            }
            
            return defaultValue;            
        }
        
        protected function _getAttribute(name:String):String {
            var value:String;
            
            if (name == "href") {
                //this._xml@href handled normally
                value = this._xml.@xlink::href;                             
                if (value && (value != "")) {
                    return value;
                }
            }
            
            var xmlList:XMLList = this._xml.attribute(name);
            
            if (xmlList.length() > 0) {
                return xmlList[0].toString();
            }   
                     
            if (_styles.hasOwnProperty(name)) {
                return (_styles[name]);
            }
            
            return null;
        }


        /**
         * Remove all child nodes
         **/        
        protected function clearChildren():void {
            while(this.numChildren) {
                this.removeChildAt(0);
            }
        }
        
                
        /**
         * Force a redraw of a node
         **/
        public function invalidateDisplay():void {
            if (this._invalidDisplay == false) {
                this._invalidDisplay = true;
                this.addEventListener(Event.ENTER_FRAME, redrawNode);                
            }            
        }

        /**
         * Force a redraw of a node and its children
         **/
        public function invalidateDisplayTree():void {
            this.invalidateDisplay();
            for(var i:Number=0; i < this.numChildren; i++) {
                if (this.getChildAt(i) is SVGNode) {
                    SVGNode(this.getChildAt(i)).invalidateDisplayTree();
                }
            }
        }


        /**
         * This method is called when the caller has changed an xml attribute
         * and wants the element to be updated. Based on which attribute
         * has changed, the element is either redrawn entirely or just
         * transformed, skipping redraw as an optimization.
         **/
        public function handleAttrChange(attrName:String, attrValue:String):void {
            switch (attrName) {
                case 'transform':
                case 'viewBox':
                case 'x':
                case 'y':
                case 'rotation':
                    this.transformNode();
                    break;

                default:
                    if (   (attrName == 'display' || attrName == 'visibility')
                        || (attrName == 'style' &&
                                (   (attrValue.indexOf('visibility') != -1 )
                                 || (attrValue.indexOf('display') != -1 ) ) ) ) {
                        this.invalidateDisplayTree();
                    }
                    else {
                        this.invalidateDisplay();
                    }
                    break;
            }
        }


        public function doRedrawNow():void {
            this.redrawNode(null);
        }

        /**
         * Triggers on ENTER_FRAME event
         * Redraws node graphics if _invalidDisplay == true
         **/
        protected function redrawNode(event:Event):void {

            if ( (this.parent != null) && (this._invalidDisplay) ) {
                this._invalidDisplay = false;
                //this.dbg("redrawNode: " + this.xml.@id + " type " + describeType(this).@name);
                if (this._xml != null) {
                
                    this.graphics.clear();
                    
                    if (!this._parsedChildren) {
                        this.parse();
                        this._parsedChildren = true;
                    }

                    this.setAttributes();

                    if (!this.isChildOfDef() && !this.isDisplayNone()) {
                        this.generateGraphicsCommands();
                        this.transformNode();
                        this.draw();
                        this.setupFilters();
                    }
                }
                
                this.removeEventListener(Event.ENTER_FRAME, redrawNode);

                if (this.xml.@id)  {
                    this.svgRoot.invalidateReferers(this.xml.@id);
                }

/*
                if ((this.getSVGMaskAncestor() == null) && !(this is SVGClipMaskParent)) {
                    var blurMask:SVGBlurMaskParent = this.getSVGBlurMaskAncestor();
                    if (blurMask) {
                        this.dbg("updating self blur mask transform " + describeType(this).@name);
                        setTimeout(function():void { blurMask.updateBlurMaskTransform() }, 10);
                    }
                }
*/

                //this.dbg("done drawing " + this.xml.@id + " type " + describeType(this).@name);
            }
            if (!(this._initialRenderDone)) {
                this._initialRenderDone = true;
                this.svgRoot.renderDone(this);
            }
        }
        
        /**
         *
         **/
        override public function addChild(child:DisplayObject):DisplayObject {
            if (child is SVGNode) {
                this.svgRoot.renderStart(SVGNode(child));
            }
            super.addChild(child);
            return child;
        }
        
        
        /**
         * Add any assigned filters to node
         **/
        protected function setupFilters():void {
            var filterName:String = this.getAttribute('filter');
            if ((filterName != null)
                && (filterName != '')) {
                var matches:Array = filterName.match(/url\(#([^\)]+)\)/si);
                if (matches.length > 0) {
                    filterName = matches[1];
                    var filterNode:SVGFilterNode = this.svgRoot.getElement(filterName);
                    if (filterNode) {
                        this.filters = filterNode.getFilters(this);
                    }
                    else {
                        //this.dbg("filter " + filterName + " not (yet?) available for " + this.xml.@id);
                        // xxx add reference
                    }
                }
            }
        }
                
        
        /**
         * @return is child of definition? they are not drawn.
         **/ 
        public function isChildOfDef():Boolean {
            var node:SVGNode = this;
            while (node && !(node is SVGRoot)) {
                node=SVGNode(node.parent);
                if (node is SVGDefsNode)
                    return true;
            }
            return false;
        }
        /**
         * Has style 'display: none' or child of parent with same? they are not drawn.
         **/ 
        public function isDisplayNone():Boolean {
            var node:DisplayObject = this;
            if (this.getAttribute('display') == 'none') {
                return true;
            }
            while (node && !(node is SVGRoot)) {
                node=node.parent;
                if (node && node is SVGNode && SVGNode(node).getAttribute('display') == 'none') {
                    return true;
                }
            }
            return false;
        }

        public function getSVGMaskAncestor():SVGMask {
            var node:DisplayObject = this;
            if (node is SVGMask)
                return SVGMask(node);
            while (node && !(node is SVGRoot)) {
                node=node.parent;
                if (node && (node is SVGMask))
                    return SVGMask(node);
            }
            return null;
        }

        public function getSVGClipMaskAncestor():SVGClipMaskParent {
            var node:DisplayObject = this;
            while (node && !(node is SVGRoot)) {
                node=node.parent;
                if (node && (node is SVGClipMaskParent)) {
                    return SVGClipMaskParent(node);
                }
            }
            return null;
        }


        public function getSVGBlurMaskAncestor():SVGBlurMaskParent {
            var node:SVGNode = this;
            while (node && !(node is SVGRoot)) {
                node=SVGNode(node.parent);
                if (node && (node is SVGBlurMaskParent)) {
                    return SVGBlurMaskParent(node);
                }
            }
            return null;
        }



        public function get invalidDisplay():Boolean {
            return this._invalidDisplay;
        }

        // Getters / Setters

        /**
         *
        **/
        public function set xml(xml:XML):void {
            this._originalXML = xml.copy();
            this._xml = xml;
            this._revision++;
            this.clearChildren();
            this._parsedChildren = false;
            this.parseStyle();
            this.invalidateDisplay();
        }
        
        public function get xml():XML {
            return this._xml;
        }

        public function get id():String {
            var id:String = this._xml.@id;
            return id;
        }

        public function get revision():int {
            return this._revision;
        }
        

        /** 
         * @private
         * Temporary function to make debugging easier 
         **/
        public function get graphicsCommands():Array {
            return this._graphicsCommands;
        }


        public function setAttribute(name:String, value:String):void {
            if (name == "style") {
                this._xml.@style = value;
                this.parseStyle();
                return;
            }

            if (this._styles.hasOwnProperty(name)) {
                this._styles[name] = value;
                updateStyle();
            }
            else {
                this._xml.@[name] = value;
            }
            
            this.handleAttrChange(name, value);
        }
 
       /**
         * Update style attribute from _styles
         * <node style="...StyleString...">
         * 
         **/ 
        private function updateStyle():void {
            var newStyleString:String = '';
            
            for (var key:String in this._styles) {
                if (newStyleString.length > 0) {
                    newStyleString += ';';
                }
                newStyleString += key + ':' + this._styles[key];
            }
            
            this._xml.@style = newStyleString;
        }
 
     
        /**
         * Load _href content and then append/replace back original content
         **/
        public function refreshHref():void {

            /**
             * If _href revision has changed, copy xml over
             **/
            var href:String = this._xml.@xlink::href;
            if (!href || href=='') {
                href = this._xml.@href;
            }
//            this.dbg("hrefresh: " + href + " mytype:" + describeType(this).@name + " myid: "+ this._xml.@id);

            if (href && href != '') {
                href = href.replace(/^#/,'');

                this._href = this.svgRoot.getElement(href);
                if (!this._href) {
                     //this.dbg("href " + href + " not available for " + this.xml.@id);
                }
            }

            if (this._href
                && (this._href.revision != this._hrefRevision)) {
                //this.dbg("Doing href refresh of " + this._xml.@xlink::href + " for " + this._xml.@id); 
                /**
                 * The call makes this refresh recursive
                 **/
                this._href.refreshHref();

                /**
                 * Copy the href
                 **/


                this._xml = this._originalXML.copy();

                /**
                 *
                 **/

                for (var index:int=0; index < this._href._xml.children().length(); index++) {
                    var childCopyXML:XML =this._href._xml.children()[index];
                    this._xml.appendChild(this.copyXMLUnique(childCopyXML).toXMLString());
                    
                }

                for each( var attr:XML in this._href.xml.attributes() ) {
                    this._xml.@[attr.name()] = attr.toString();
                }

                /**
                 * Replace the previous attributes since they have
                 * precedence over referenced xml.
                 **/
                for each( var myattr:XML in this._originalXML.attributes() ) {
                    if (myattr.name()  != "style") {
                        this._xml.@[myattr.name()] = myattr.toString();
                    }
                    else {
                        if (this._xml.@style) {
                            this._xml.@style = SVGNode.overwriteStyles(this.xml.@style, myattr.toString);
                        }
                        else {
                            this._xml.@style = myattr.toString;
                        }
                    }
                }


                this._revision++;
                this._hrefRevision = this._href._revision;
            }
            else {
                //this.dbg("NOT Doing href refresh of " + this._xml.@xlink::href + " for " + this._xml.@id); 
                //this.dbg("2NOT Doing href refresh of " + this._href + " type " + (typeof this._href)); 
            }
            return;
        }

        public function copyXMLUnique(originalXML:XML):XML {
            var myXML:XML = originalXML.copy();
            this.makeUniqueIDs(myXML);
            return myXML;
        }

        public function makeUniqueIDs(xmlNode:XML):void {

            if (xmlNode.@id && (xmlNode.@id != undefined)) {
               xmlNode.@id = xmlNode.@id + ".copy" + Math.random().toString();
            }
            else {
               xmlNode.@id = "copy" + Math.random().toString();
            }
            for each (var childXML:XML in xmlNode.children()) {
                this.makeUniqueIDs(childXML);
            }

        }

        public function dbg(debugString:String):void {
            this.svgRoot.debug(debugString);
        }

    }
}
