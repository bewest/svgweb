
Frequently Asked Questions
------------------------------------------------------------

Basic
    Basic.1: What is svgviewer?
    Basic.2: What is SVG? Where can I get SVG files?
    Basic.3: Why does svgviewer exist?
    Basic.4: Who wrote svgviewer?
    Basic.5: What is sgweb?

Deployment
    Dep.1: What is the simplest way to include an SVG image on my web page?
    Dep.2: How can I use an SVG image from SVG content that is stored inline in my web page?
    Dep.3: How can I change the default background color?

Sizing
    Size.1: What is the relationship between SVG drawing coordinates
            and screen pixel coordinates?
    Size.2: How do I make the size of an SVG object resize along with the
            browser window, ignoring the object's original aspect ratio?
    Size.3: How do I make the size of an SVG object resize along with the
            browser window, but maintain the object's original aspect ratio?
    Size.4: How do I make the size of an SVG object fit a given % of the
            screen size and resize along with the browser?

Limitations
    Limit.1: What parts of SVG are not implemented?

Issues:
    Issue.1: Why is there a flicker when the SVG is first rendered?

Scripting
    Script.1: What javascript helper functions are available for loading SVG content?
    Script.2: What javascript functions are available as part of the standard W3C SVG interface?
    Script.3: Are there any quirks to be aware of with the SVG scripting support?

Future
    Future.1: What are the plans for SVGViewer?
    Future.2: Will this project promote the adoption of SVG?





Answers
------------------------------------------------------------

Basic
    Basic.1: What is SVGViewer?
        SVGViewer is a flash "movie" which renders Scalable Vector Graphics (SVG) files.

    Basic.2: What is an SVG file? Where can I get SVG files?
        Scalable Vector Graphics (SVG) files are graphical images that are stored in XML format.
        Vector graphics can scale to any size without degradation unlike bitmap images which become pixelated (grainy).
        You can find many freely available SVG files at http://www.openclipart.org.
        You can use the freely available Inkscape application to create and edit SVG files.

    Basic.3: Why does SVGViewer exist?
        Internet Explorer does not support SVG files. An option to support SVG on Internet Explorer
        was desired that did not require the user to install anything.  Adobe has provided a plug-in but it
        requires installation and is scheduled for end of support. So, this flash shim was created to allow
        SVG files to be supported without requiring anything other than flash, which over 90% of users already
        have installed.

    Basic.4: Who wrote SVGViewer?
        The original core was written by James Hight and released under MIT license in September of 2008.
        Rick Masters took that code and created a new project, http://code.google.com/p/sgweb,
        on October 11th, 2008. Rick then added support for linear and radial gradients, xlink cross
        references, gaussian blurs, and javascript scripting and fixed numerous minor issues.
        Rick can be contacted here: grick23 at gmail.com.

    Basic.5: What is sgweb?
        sgweb is the project that Rick Masters started as an umbrella project for scalable graphics
        utilities for web browsers. Simply put: sgweb is the parent project for svgviewer.
        The sgweb project seeks to promote vector markup languages in web browsers and is agnostic
        on technology. The first utility of this project is svgviewer. There may be other utilities
        added to the sgweb project for other technologies in the future such as Xaml, javafx, or fxg.

Deployment
    For simple deployments, place svgviewer.swf in the same directory as your html and svg file.

    Dep.1: What is the simplest way to include an SVG image on my web page?
        See com/sgweb/svg/release/svg_loadfile_js.html

    Dep.2: How can I use an SVG image from SVG content that is stored inline in my web page?
        See com/sgweb/svg/release/svg_inline.html

    Dep.3: How can I include an SVG image on my web page without using javascript?
        See com/sgweb/svg/release/svg_loadfile.html

    Dep.4: How can I include multiple inline SVG images?
        See com/sgweb/svg/release/svg_inline_many.html

Sizing
    Size.1: What is the relationship between SVG drawing coordinates and
            browser pixel coordinates?
            The SVG drawing coordinates are draw initially to the flash
            coordinate system which are then mapped to browser coordinates.
            SVGViewer tells flash at compile time what the size of the "movie"
            is. The width and height of the flash area is defined at the top
            of SVGViewer.as in the [SWF] directive. Currently, this is 2048
            by 1024.

            When you use svgviewer in your web page you specify a height and
            width (either in the <object> tag or by passing in parameters to
            javascript functions) and then the flash coordinates are mapped
            into that height and width by flash. Flash uses the Stage.scaleMode
            parameter to determine exactly how the scaling is done. By default,
            it sizes the image to the object to a size which allows you to see
            the entire image within the area, preserves the aspect ratio, and
            is as large as possible within those constraints ("showAll").

            If you specify a width and height of an SVG object as 512 by 256,
            then the image will appear four times smaller than would be
            rendered by SVG if loaded natively by the browser because it must
            scale the 2048x1024 flash axis each by .25 to get to 512x256.

            Now, the interesting quirk of design comes in here. The method by
            which flash scales the control is based on the aspect ratio of the
            html object parameters. In contrast, in the case of a native SVG loaded
            into your browser, there are no such parameters and the image is
            scaled according to the aspect ratio of the root <svg> element.
            This aspect ratio is based on the width and height parameters of the top
            svg element if they exist. If a viewBox is present, the aspect ratio
            of the viewBox is used instead. If neither of these exist, the width
            and height default to 100% by 100%, which refers to the containing
            object. In our case, the containing object is the flash control, with
            a virtual area of 2048x1024, as specified in the source code.

            The problem with the above discrepency arises when the top svg element
            uses a viewbox or width/height that is more tall than wide. In this case,
            when the browser renders the SVG natively, it correctly places borders
            on the sides. However, in our case, unless we specify an object size that
            is wider in aspect resolution than 2048x1024 (unlikely), flash resizing
            still places the borders on the top and bottom because it still thinks the
            object is more wide than tall (2048x1024). So, we cannot rely on flash resizing
            to help us scale the svg the right way because it is not aware
            of the svg aspect ratio. Therefore, an additional scaleMode is implemented
            by SVGViewer to implement the SVG behavior for the corresponding
            flash "showAll" scaleMode. This is named "showAll_svg". This mode works
            by disabling flash scaling with the "noScale" mode and then performing the
            scaling manually in SVGViewer.

            The flash "showAll" behavior (which is the flash default) is named
            "showAll_flash" in this library to remove ambiguity with "showAll_svg".
            With the existing 2048x1024 size, "showAll_flash", will always
            have borders at the top and bottom. Correspondingly, if you created
            a flash control that was more tall than wide, its borders would always be
            on the sides, regardless of the SVG aspect resolution.

            A design goal is to replicate what a browser would do with a raw svg file.
            The default scaleMode is therefore "showAll_svg" because this should
            result in that behavior. This mode prefers the svg scaling behavior
            above the flash control scaling behavior in precedence. This is the
            design quirk. However, it is presumed that users of this library will prefer
            that the 'right' svg thing will occur by default and the flash issue of
            2048x1024 is something they can ignore and perhaps remain blissly unaware of.

    Size.2:
    Size.3:
    Size.4:
            Just create the SVG using the appropriate flash scaleMode and set the html object width
            and height to the size you want in your javascript resize event handler.
            See FAQ Size.1 and the flash documention for Stage.scaleMode here:
            http://livedocs.adobe.com/flash/9.0/ActionScriptLangRefV3/flash/display/Stage.html#scaleMode
       


Limitations

    Limit.1: What parts of SVG are not implemented?
        * Compressed SVG files are not supported directly. However, it should not be too
          difficult to have your web server gzip files for you (which your browser will unzip),
          especially when you use the inline html format.

        * Animations are not yet supported. This is coming.

        * Only a few script events are supported (onload and mouse and keyboard events)

        * Getter/Setter scripting syntax (e.g. myobj.style.visibility='hidden') are partially implemented
          for Firefox/Safari, but it is not supported on IE.
              (Use this syntax instead: myobj.setAttribute('visibility', 'hidden'))
              For IE6&7, the future plan is to replace this syntax with regex translations to the setAttribute syntax.
              For IE8, there is an alternate getter/setter syntax that can be used but it has not been implemented yet here.

        * script method getElementsByTagName() is not yet implemented

        * script method removeChild() is not yet implemented

        * script DOM types like "var foo=new Path()" are not implemented. You can use createElementNS(SVGNS, 'path') instead.

        * Only the gaussian blur filter is implemented. No plan to support other filters (which are rarely used).

        * Off center radial gradients (which are rarely used) are not yet supported.

        * External links to other svg files (which are rarely used) are not supported. 

        * Views (which are rarely used) are not supported. 

        * SVG Masks (which are rarely used) are not supported. As a best effort, clipping paths
               are used in their place. No plans to support further.

        * Patterns (which are rarely used) are not supported. No plan to support at this time.

        * Markers (which are rarely used) are not supported. No plan to support at this time.


Issues
    Issue.1: Why is there a flicker when the SVG is first rendered?
        Flicker at the end of the initial rendering can occur if you use automatic resizing. To avoid this,
        make sure to specify an object 'width' and 'height' with your createSVG parameters and leave the
        "sizeToSVG" parameter set to false. If you do not specify width or height, or if you set sizeToSVG to
        true, then svgviewer assumes you want the html object to have the same height and width as the SVG
        file. However, it does not know what the size of the SVG file is until it loads it. Before it is loaded,
        the object has to have some height and width. If you do not tell svgviewer what size to use, the object
        will have a width and height of 2048 and 1024 respectively. Once the SVG file is loaded, it resizes
        to the correct size.

        Here is how automatic resizing works.  After the svg image is loaded, flash tells javascript what the
        height and width of the SVG file is (which it gets from the top <svg> tag). Javascript then resizes the
        object by changing the width and height attributes of the html object. When this occurs, flash receives a
        resize event and then it transforms the image to fit in the new area.  In the brief moment between when the
        object resizes and when flash resizes, the image will be off center and that results in a "herky jerky"
        effect. To avoid that, the image is briefly hidden and then unhidden using html styles. When it is unhidden,
        it will not be off center because flash will have already repositioned by then. It only takes a moment for
        flash to reposition.  This hide and unhide causes the flicker. Another alternative is to not display anything
        until the entire object is drawn and resized properly. This is probably the most technically correct behavior.
        However, for large SVG files, this results in absolutely no drawing feedback to the user for possible a very
        long time. For now, this will not be the behavior. You can simulate this behavior by using a width and height
        of 1, but be sure the SVG file has a height and width (which is not a %), or else it will not resize any
        bigger! A future setting will allow choosing between "hide for resize" (the current default), "herky jerky",
        and "hide until done." The goal is to add a progress indicator for drawing large files, in which case it
        would then be acceptable to make "hide until done" the future default for this setting.



Scripting

    Script.1: What javascript helper functions are available for loading SVG content?
        params = { parentId: ... ,
                   uniqueId: ... ,
                   objectWidth: ... ,
                   objectHeight: ... ,
                   svgId: ... ,
                   bgcolor: ... ,
                   scaleX: ... ,
                   scaleY: ... ,
                   translateX: ... ,
                   translateY: ...
                 }
        sgweb.createSVG(params)


    Script.2: What javascript methods are available as part of the standard W3C SVG interface?
        (note these are not yet implemented)
        createAttributeNS
        createElementNS
        getAttributeNodeNS
        getAttributeNS
        getElementsByTagNameNS
        getNamedItemNS
        hasAttributeNS
        removeAttributeNS
        removeNamedItemNS
        setAttributeNS
        setAttributeNodeNS
        setNamedItemNS

        createTextNode

        Example:
            var svgNS = 'http://www.w3.org/2000/svg';
            var foo_g = createElementNS(svgNS, 'g')
            foo_g.getAttributeNS(null, 'x');
            foo_g.setAttributeNS(svgNS, 'x', '100');

    Script.3: Are there any quirks to be aware of with the SVG scripting support?
        Yes, the interface is implemented in a rather complex way. There is a possibility that a script
        which does something unusual will not work properly. Be aware that the javascript evaluator
        replaces certain patterns in the javascript in order to intercept certain necessary methods.
        For example, 'document.createElementNS' is replaced with 'svgviewer.document.createElementNS'
        which actually implements that method. This is done because the top level document variable apparently
        cannot be altered. So, if the script invokes a document method in an unusual way, like
        eval('doc'+'ument...') for example, it will not be executed because the pattern replacement does not
        recognize that and so the method not get replaced with the svgviewer method.


Future
    Future.1: What are the plans for SVGViewer?
        The current author tends to work on specific SVG files until they render as well as possible, fixing
        or implementing new functionality along the way. Currently all files render well, however scripting is
        a work in progress. If you have an SVG file that you would like me to work on, send it to grick23@gmail.com.
        The current task list, as of Dec 26 2008, is:
        1. Improve javascript scripting in order to support photos.svg on IE
        2. IE getter/setter support (IE8 natively)
        3. Animations

    Future.1: Will this project help promote the adoption of SVG?
        One can only hope. The main reason for this project is because Microsoft Internet Explorer does
        not support SVG natively. In my opinion, it is unlikely that it ever will. So, the best way folks can
        support SVG is to use the latest version of Firefox which supports SVG natively. If you are an IT
        professional, please take some time to install Firefox and make it the default browser on all of
        the computers in your family! Perhaps as Microsoft's market share diminishes, they will rethink
        their support for SVG. That is the path to really sweet SVG browser support, but it is a long road.
        In the mean time, it is hard to ignore the current large market share of Internet Explorer. Someday
        down the road, if its market share drops below 20% or so, I would choose to ignore it. That would
        make business sense as well since it would allow for more efficient and advanced web development
        and that would probably offset the lost market share. But for a lot of developers, they cannot
        make that choice right now. Therefore they need a way to support IE.

        Once you make the decision to support IE, your choices for advanced vector graphics are limited to flash.
        Java and Silverlight are wonderful, and I've used them extensively, but few developers want to require
        their users to download a plugin, which is what those technologies require. Neither one seems destined
        to gain significant market share in the immediate future unless there are dramatic new developments in
        that area. 

        Now, if you are using flash, the question is whether to code in flash actionscript. The problem I have with
        that is the lack of dynamic execution support. The application has to be coded and compiled into a binary
        movie.  If I want to pull down additional functionality, it comes in a separate movie. If I want to do
        mashups, I have a significant challenge with flash. I like Silverlight in this respect. I can
        load graphics from a Xaml file or from Xaml inline with HTML or I can create graphics from a
        string using the javascript method createFromXaml("<Canvas...><Rect...></Canvas>"). I can download more
        javascript like any AJAX application. The problem with Xaml is that it does not have a huge following in
        the web development community. They have mixed feelings on Flash (probably more negative) but there seems
        to be a general respect for SVG, but an awareness of its lack of support by IE. So, it seems that if
        the support for IE can be provided, SVG might attract more web developers.

        I will note that, personally, I prefer to code in browser javascript where I can do my vector graphics and
        html DOM functionality in one code base. So Actionscript does not work for me. Also, Actionscript is
        using a variant of ecmascript which is a bit more type oriented for my tastes in a scripting
        language. Also, recent developments indicate that variant is unlikely to be adopted by browser vendors
        for a long time, if ever.

        My recommendation for web developers is develop their graphics using this control and
        test against firefox native support to ensure interoperability (or visa versa). It is not too difficult
        to figure out what is supported by both firefox and SVGViewer. If you stay within those lines, you
        can enjoy the advanced graphics that SVG provides. If you find SVGViewer does not support what you want,
        the source is available and the tools to build it are free. You can build your own SVGViewer SWF
        file patched just for your website if you wish. And remember, your users will not have to install
        anything.


