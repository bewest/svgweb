<html xmlns:svg="http://www.w3.org/2000/svg">

<head>
  <!-- 
    The 'lightWeight' attribute below is important for two reasons:
    * It vastly improves performance
    * There is a bug that Behaviors are not cached correctly, so without
      this property the same HTC file will get called for every SVG element
      on the page. The lightWeight property sidesteps this bug.
  -->
  <public:component lightWeight="true">

      <!-- 
        Grab the SVG inside of an SVG root element and
        process it by the Flash viewer.
      -->
      <public:method name="processSVG" />
      
      <public:method name="setAttribute" />
      <public:method name="getAttribute" />
      <public:method name="addEventListener" />
      
      <public:method name="setAttached" />
      <public:method name="getListeners" />
      
      <public:property name="attached" value="false" internalname="_attached" />
      <public:property name="listeners" internalname="_listeners" />
      <public:property name="libraryPath" value="./" />
       
      <public:attach event="oncontentready" onevent="contentReady()" />
      <public:attach event="onpropertychange" onevent="propertyChange()" />
      
      <public:defaults tabStop="false" contentEditable="false"
                        canHaveHTML="true" viewInheritStyle="true"
                        viewMasterTab="false" viewLinkContent="false"
                        style="display: block" />

  </public:component>

  <script type="text/javascript">
      function getViewer() {
        //console.log('getViewer');
        
        // we need to get the doc object; we
        // might already have this if we are the root node. However,
        // if we are a child SVG node then we will need to get it, 
        // then cache it to use over and over
        if (typeof this.doc == 'undefined') { // not root node
          // loop until we get our root SVG node
          var root = element.parentNode;
          while (root) {
            if (root.nodeName.toUpperCase() == 'SVG') {
              break;
            }
            
            root = root.parentNode;
          }
            
          if (!root) {
            throw new Error('Unable to find root SVG node');
          }
          
          this.doc = root.doc;
        }
        
        if (typeof this._flashElement == 'undefined') {
          this._flashElement = this.doc.getElementsByTagName('object')[0];
        }
        
        return this._flashElement;
      }

      // watch to see when anyone changes a 'style' property so we
      // can mirror it in the Flash control
      function propertyChange() {
        //console.log('onpropertychange');
        // TODO: Implement
        var prop = window.event.propertyName;
        if (prop && /^style\./.test(prop)) {
          var styleName = prop.match(/^style\.(.*)$/)[1];
          //console.log(prop + ' changed to ' + this.style[styleName]);
        }
      }
    
      function contentReady() {
        // We are a dynamically created DOM node and are now live
        if (!this.isAttached() && ownerDocument.readyState == 'complete') {
          this._attached = true;
          // Now that this DOM node is live, pass its contents down into
          // the Flash viewer (but don't do this if we are working with
          // an SVG root node since there's nothing to display yet)
          if (this.nodeName.toUpperCase() != 'SVG') {
            this.processSVG();
            return;
          }
        }
        
        // only insert Flash for the root SVG node
        if (this.nodeName.toUpperCase() != 'SVG') {
          return;
        }
        
        console.log('HTC contentReady');
        
        // get the path to our library resources that we set in the
        // svg.js FlashSVG constructor
        this.libraryPath = window.__svg__libraryPath;

        // generate a random ID for ourselves if we don't have one
        if (!this.id) {
          this.id = this.generateID('__svg__', null);
        }
      
        // get the desired width and height for this element
        var width = this.width;
        var height = this.height;
        
        if (width == undefined || height == undefined) {
          var msg = "Width and height must be defined on the SVG root node";
          console.log(msg);
          throw msg;
        }
        
        if (/px\s*$/.test(width)) {
          width = new Number(width.match(/^\s*(\d+)px\s*$/)[1]);
        }
        
        if (/px\s*$/.test(height)) {
          height = new Number(height.match(/^\s*(\d+)px\s*$/)[1]);
        }
        
        console.log('width='+width);
        console.log('height='+height);
        
        // have the Flash object either be transparent or drawn so
        // it can have z-ordering
        var wmode = 'opaque';
        if (this.currentStyle.backgroundColor == 'transparent') {
          // no background color specified
          wmode = 'transparent';
        }
      
        // IE is extremely sensitive to how we embed the Flash control into
        // the page; if we do it the wrong way, it will either fail to display
        // or aspects of ExternalInterface will not work. Don't change the
        // code below without extensive testing. Some notes on the approach:
        // * I found that building up the object programmatically (i.e. using DOM
        //  methods) does not work; I had to do it as a giant HTML string
        // * We have to use a DIV container; since we don't want this DIV to
        // stay around, acting almost like a DocumentFragment, we use
        // div.outerHTML on it to have the Flash control go into it and have the
        // DIV 'disappear' in a poof of smoke
      
        // Adapted from Dojo Flash
        var objectHTML =
          '<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" '
            + 'codebase="'
            + window.location.protocol /* important for https pages to work */
            + '//fpdownload.macromedia.com/pub/shockwave/cabs/flash/'
            + 'swflash.cab"\n '
            + 'width="' + width + '"\n '
            + 'height="' + height + '">\n '
            + '<param name="Movie" value="' + this.libraryPath + 'svg.swf"></param>\n '
            + '<param name="wmode" value="' + wmode + '"></param>\n '
            + '<param name="AllowScriptAccess" value="always"></param>\n '
            + '<param name="FlashVars" value="svgID=' + this.id + '"></param>\n '
          + '</object>';

        // We use the Behavior ViewLink trick to 'hide' this shadow content from 
        // the external page, so that we don't see the Flash object in the 
        // external DOM. For more details on ViewLinks: 
        // http://msdn.microsoft.com/en-us/library/ms531428(VS.85).aspx
        // Note, though, that we want to keep almost all of our SVG elements
        // 'lightWeight' (see the lightWeigth attribute on the
        // public:component tag at the top of this file) because
        // non-lightWeight components have performance and caching issues.
        // LightWeight HTC components however can not use View Links or have
        // shadow content.
        // As a trick, we 'convert' ourselves into having a shadow DOM
        // just for the SVG root tag by manually creating an HTML document below,
        // then storing this document in this.doc for later retrieval.
        // For the trick to work we also have to set some public:defaults
        // above at the top of this file.
        // This approach successfully keeps the performance benefits of
        // lightWeight HTCs while being able to have shadow content that
        // doesn't show up in the external DOM.
        var html = element.document.createElement('html');
        var body = element.document.createElement('body');
        var div = element.document.createElement('div');
        body.appendChild(div);
        html.appendChild(body);
        defaults.viewLink = html.document; // ViewLink magic
        this.doc = html.document;
        // outerHTML must be set _after_ DIV is added to DOM for
        // Flash ExternalInterface to work correctly
        div.outerHTML = objectHTML;  
        
        // If we use the Behavior ViewLink trick to 'hide' the Flash object
        // from the external page's DOM, then Flash's ExternalInterface
        // doesn't work correctly. That's ok, we can fix this with some
        // tricks from Dojo Flash. More details on these
        // hidden Flash methods here:
        // http://codinginparadise.org/weblog/2006/02/how-to-speed-up-flash-8s.html
        var viewer = getViewer();
        viewer.parseBrowserSVG = getFlashFunction('parseBrowserSVG');
        viewer.__svg__getAttribute = getFlashFunction('__svg__getAttribute');
        viewer.__svg__setAttribute = getFlashFunction('__svg__setAttribute');
        viewer.__svg__appendChild = getFlashFunction('__svg__appendChild');
        
        // make our visibility hidden until we are done to prevent flashing
        // TODO: Get this working again
        //this.style.visibility = 'hidden';
      }
      
      function getFlashFunction(method) {
        return function() {
          return eval(this.CallFunction(
            "<invoke name=\"" + method + "\" returntype=\"javascript\">" 
            + __flash__argumentsToXML(arguments, 0) + "</invoke>"));
        }
      }
    
      function processSVG() {
        //console.log('processSVG');
        
        // every SVG node needs an ID so we can do registration
        // between our shadow DOM and the one in Flash
        this.addIDs();
      
        // get the SVG markup and clean it up
        var data = this.getSVG();
        //console.log('data='+data);

        // now pass our SVG into the Flash viewer to render
        var viewer = this.getViewer();
        if (this.nodeName.toUpperCase() == 'SVG') {
          console.log('calling parseBrowserSVG');
          var self = this;
          window.setTimeout(function() {
            viewer.parseBrowserSVG(data, self.id);
          }, 1000);
        } else {
          var parentId = this.parentNode.id;
          viewer.__svg__appendChild(data, parentId);
        }
        
        // clear out the background color so it gets rendered by the Flash SVG
        // viewer instead
        this.style.backgroundColor = '';
        
        // become visible now to prevent flashing
        // TODO: Get this working again
        //this.style.visibility = 'visible';
      }
      
      function addIDs() {
        // every SVG node needs an ID so we can do registration
        // between our shadow DOM and the one in Flash
        var current = element;
        while (current) {
          if (!current.id && current.nodeType == 1) {
            current.id = this.generateID('__svg__', null);
          }

          var next = current.firstChild;
          if (next) {
            current = next;
            continue;
          }

          while (current) {
            if (current != element) {
              next = current.nextSibling;
              if (next) {
                current = next;
                break;
              }
            }

            if (current == element) {
              current = null;
            } else {
              current = current.parentNode;
              if (current.nodeType != 1
                  || current.nodeName.toUpperCase() == 'SVG') {
                current = null;
              }
            }
          }
        }
      }
      
      function getSVG() {
        // get the SVG markup and clean it up
        var data = this.outerHTML;
        
        if (this.nodeName.toUpperCase() == 'SVG') {
          // IE adds <?xml:namespace declaration at the beginning; remove it
          data = data.replace(/<\?xml:namespace[^\>]*\>/, '');
          
          // IE also can add an <?IMPORT declaration sometimes -- get rid of it
          data = data.replace(/<\?import[^>]*\/>/mi, '');
          
          // This can leave a leading newline -- remove it if present
          if (data.charAt(0) == '\n') {
            data = data.substring(1);
          }
          
          // add the SVG namespace declaration onto the root SVG node
          // if it is not there
          var rootStr = data.match(/^(<svg:svg[^>]*>)/im);
          if (rootStr && rootStr.length > 0 
              && rootStr[1].indexOf('xmlns:svg') == -1) {
            data = data.replace(/\<svg:svg /, 
                              '<svg:svg xmlns:svg="http://www.w3.org/2000/svg" ');
          }
        } else {
          // strip off the <?import portion for non-SVG root tags
          data = data.replace(/<\?import[^>]*>/m, '');
          data = data.replace(/^\s*/m, '');
          
          // add namespace declarations to this node
          data = data.replace(new RegExp('^<svg:' + this.nodeName), 
                              '<svg:' + this.nodeName
                              + ' xmlns:svg="http://www.w3.org/2000/svg" '
                              + ' xmlns:xlink="http://www.w3.org/1999/xlink" ');
        }
        
        // if there is an 'id' attribute IE strips out the quotes; replace them
        data = data.replace(/id=([^\'\"][^ >]+)(\s|>)/gim, 'id="$1"$2');
        
        // same thing if there is a 'class' attribute
        data = data.replace(/class=([^\'\"][^ >]+)(\s|>)/gim, 'class="$1"$2');
        
        // IE will capitalize some properties in inline style expressions,
        // such as style='DISPLAY: none;'
        // FIXME: both of these will break if there is an inline encoded quote,
        // such as for the content() CSS style attribute
        data = data.replace(/(style=)(')([^']*)(')/gm, '$1"$3"');
        var styleMatches = data.match(/style="[^"]*"/gm);
        for (var i = 0; styleMatches != null && i < styleMatches.length; i++) {
          var oldMatch = styleMatches[i];
          var newMatch = oldMatch;
          var styleAttrs = newMatch.match(/[A-Z_\-0-9]+\:/gm);
          if (styleAttrs == null) {
            continue;
          }
          for (var j = 0; j < styleAttrs.length; j++) {
            newMatch = newMatch.replace(styleAttrs[j], styleAttrs[j].toLowerCase());
          }
          data = data.replace(oldMatch, newMatch);
        }
        
        // sometimes, an onclick= handler will lose it's quotes if there
        // is an attribute afterwards.
        // Example evil IE mangling: 
        // <svg:g id=modeButton onclick=toggleDistribution(); fill="url(#stopButt)">
        //
        // To Fix (only safe way):
        // Identify nodes with onclicks, get their IDs, grab them from the DOM,
        // get their correct onclick values, and then fill this back in the string
        var onclickNodes = data.match(/(<svg:\w+[^>]+(?=onclick=)[^>]+>)/gm);
        for (var i = 0; onclickNodes != null && i < onclickNodes.length; i++) {
          var markup = onclickNodes[i];
          var onclickID = markup.match(/id="([^\"]*)"/)[1];
          var onclickNode = element.ownerDocument.getElementById(onclickID);
          var onclickCode = onclickNode.onclick.toString()
          // IE wraps as anonymous function -- strip
          onclickCode = onclickCode.replace(/^function\s*anonymous\(\)\s*\{\s*/gm, '');
          onclickCode = onclickCode.replace(/\s*\}\s*$/gm, '');
          // backslash double quotes
          var newCode = onclickCode.replace(/\"/gm, '\\"');
          // now inline the correct new onclick code
          RegExp.multiline = true;
          var newMarkup = markup.replace('onclick='+onclickCode, 
                                          'onclick="' + newCode + '"');
          // now inline the entire changed node
          data = data.replace(markup, newMarkup);
        }
        
        // FIXME: The Flash SVG Viewer doesn't work when you have spaces
        // after style attribute names (fill: red for example); fix this there
        data = data.replace(/: /g, ':');
        data = data.replace(/; /g, ';');
        data = data.replace(/>/g, '>\n');
        
        // IE strips out the final semicolon from style lists
        // FIXME: I think this will break for style properties with just
        // one value
        data = data.replace(/style="([^"]*)"/gm, 'style="$1;"');
        
        // If there is a proprietary 'attached' attribute strip it
        data = data.replace(/\s*_attached="(?:true|false)"\s*/mgi, '');
        
        return data;
      }
      
      function generateID(prefix, postfix) {
        // generate an ID for this element
        if (!postfix) {
          postfix = '';
        }
        
        if (!prefix) {
          prefix = '';
        }
        
        var newID = null;
        // keep generating random IDs until we find one not taken
        while (newID == null || element.ownerDocument.getElementById(newID)) {
          newID = prefix + Math.round(Math.random() * 100000 + 1) + postfix;
        }
        
        return newID;
      }
      
      function isAttached() {
        // HTC 'Properties' are initially returned as strings, even
        // if they are boolean
        return this._attached == 'true' || this._attached == true ? true : false;
      }
      
      function setAttached(attach, recursive) {
        // we use a method (setAttached) to set this property
        // rather than use a public:property setter so that we
        // can have a second argument, 'recursive'.
        
        if (!recursive) {
          this._attached = attach;
          return;
        }
        
        // set ourselves and all our children as being attached 
        var current = element;
        while (current) {
          if (current.nodeType == 1) {
            current.setAttached(attach, false);
          }

          var next = current.firstChild;
          if (next) {
            current = next;
            continue;
          }

          while (current) {
            if (current != element) {
              next = current.nextSibling;
              if (next) {
                current = next;
                break;
              }
            }

            if (current == element) {
              current = null;
            } else {
              current = current.parentNode;
              if (current.nodeName.toUpperCase() == 'SVG') {
                current = null;
              }
            }
          }
        }
      }
      
      function getListeners(eventName) {
        if (!this._listeners) {
          return [];
        } else if (!this._listeners[eventName]) {
          return [];
        } else {
          return this._listeners[eventName];
        }
      }
      
      // override some DOM methods to have our own behavior
      
      function getAttribute(attr) {
        //console.log('getAttribute, attr='+attr);
        if (this.isAttached()) {
          return getViewer().__svg__getAttribute(element.id, attr);
        } else {
          return this[attr];
        }
      }
    
      function setAttribute(attrName, attrValue) {
        //console.log('setAttribute, attrName='+attrName);
        // TODO: Should this return the _original_ value? Look at the spec
        if (this.isAttached()) {
          return getViewer().__svg__setAttribute(element.id, attrName, attrValue);
        } else {
          this[attrName] = attrValue;
          return this[attrName];
        }
      }
      
      function addEventListener(eventName, callMe, capture) {
        if (!this._listeners) {
          this._listeners = new Object();
        }
        
        // TODO: Make more generic for other SVG event types
        // as well as capturing
        if (eventName == 'SVGLoad') {
          var onloadListeners = this._listeners[eventName];
          if (onloadListeners == undefined) {
            onloadListeners = [];
          }
          onloadListeners.push(callMe);
          this._listeners[eventName] = onloadListeners;
        }
      }
  </script>
</head>
</html>